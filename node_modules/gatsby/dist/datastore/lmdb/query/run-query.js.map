{"version":3,"sources":["../../../../src/datastore/lmdb/query/run-query.ts"],"names":["doRunQuery","args","context","createQueryContext","nodeId","getFilterById","node","datastore","getNode","entries","GatsbyIterable","totalCount","runCountOnce","canUseIndex","Promise","all","nodeTypeNames","map","typeName","suggestedIndexFields","performIndexScan","performFullTableScan","sortFields","result","indexMetadata","needsSorting","nodes","filterNodes","concat","canUseIndexForSorting","mergeSorted","createNodeSortComparator","unlimited","skip","limit","undefined","sortedNodes","sortNodesInMemory","slice","runCount","count","needsFiltering","countNodes","completeFiltering","iterateNodesByType","_","e","usedQueries","reverse","Array","from","values","value","filter","Boolean","intermediateResult","Set","dbQueries","isFullyFiltered","resolvedNodes","store","getState","resolvedNodesCache","filtersToApply","q","has","resolvedFields","get","internal","type","id","dottedField","tmp","isArray","some","v","arr","sort","queryArgs","firstOnly","databases","Map","fields","field","i","order","size","length","index","indexKeyFields","keyFields","sortOrder","comparator","DbComparator","EQ","String","nodeComparator","a","b","resolvedAFields","resolvedBFields","direction","valueA","valueB","compareByKeySuffix","prefixLength","aSuffix","key","bSuffix"],"mappings":"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","sourcesContent":["import {\n  IDataStore,\n  ILmdbDatabases,\n  IQueryResult,\n  IRunQueryArgs,\n} from \"../../types\"\nimport { IGatsbyNode } from \"../../../redux/types\"\nimport { GatsbyIterable } from \"../../common/iterable\"\nimport {\n  createDbQueriesFromObject,\n  DbComparator,\n  DbQuery,\n  dbQueryToDottedField,\n  getFilterStatement,\n  IDbFilterStatement,\n  prepareQueryArgs,\n} from \"../../common/query\"\nimport {\n  createIndex,\n  getIndexMetadata,\n  IIndexMetadata,\n  IndexFields,\n} from \"./create-index\"\nimport {\n  countUsingIndexOnly,\n  filterUsingIndex,\n  IIndexEntry,\n} from \"./filter-using-index\"\nimport { store } from \"../../../redux\"\nimport { isDesc, resolveFieldValue, shouldFilter, compareKey } from \"./common\"\nimport { suggestIndex } from \"./suggest-index\"\n\ninterface IDoRunQueryArgs extends IRunQueryArgs {\n  databases: ILmdbDatabases\n  datastore: IDataStore\n}\n\ntype SortFields = Map<string, number>\n\ninterface IQueryContext {\n  datastore: IDataStore\n  databases: ILmdbDatabases\n  dbQueries: Array<DbQuery>\n  sortFields: SortFields\n  nodeTypeNames: Array<string>\n  suggestedIndexFields: IndexFields\n  indexMetadata?: IIndexMetadata\n  limit?: number\n  skip: number\n  totalCount?: number\n}\n\nexport async function doRunQuery(args: IDoRunQueryArgs): Promise<IQueryResult> {\n  // Note: Keeping doRunQuery method the only async method in chain for perf\n  const context = createQueryContext(args)\n\n  // Fast-path: filter by node id\n  const nodeId = getFilterById(context)\n  if (nodeId) {\n    const node = args.datastore.getNode(nodeId)\n    return {\n      entries: new GatsbyIterable(node ? [node] : []),\n      totalCount: async (): Promise<number> => (node ? 1 : 0),\n    }\n  }\n\n  const totalCount = async (): Promise<number> => runCountOnce(context)\n\n  if (canUseIndex(context)) {\n    await Promise.all(\n      context.nodeTypeNames.map(typeName =>\n        createIndex(context, typeName, context.suggestedIndexFields)\n      )\n    )\n    return { entries: performIndexScan(context), totalCount }\n  }\n  return { entries: performFullTableScan(context), totalCount }\n}\n\nfunction performIndexScan(context: IQueryContext): GatsbyIterable<IGatsbyNode> {\n  const { suggestedIndexFields, sortFields } = context\n\n  let result = new GatsbyIterable<IGatsbyNode>([])\n  for (const typeName of context.nodeTypeNames) {\n    const indexMetadata = getIndexMetadata(\n      context,\n      typeName,\n      suggestedIndexFields\n    )\n    if (!needsSorting(context)) {\n      const nodes = filterNodes(context, indexMetadata)\n      result = result.concat(nodes)\n      continue\n    }\n    if (canUseIndexForSorting(indexMetadata, sortFields)) {\n      const nodes = filterNodes(context, indexMetadata)\n      // Interleave nodes of different types (not expensive for already sorted chunks)\n      result = result.mergeSorted(nodes, createNodeSortComparator(sortFields))\n      continue\n    }\n    // The sad part - unlimited filter + in-memory sort\n    const unlimited = { ...context, skip: 0, limit: undefined }\n    const nodes = filterNodes(unlimited, indexMetadata)\n    const sortedNodes = sortNodesInMemory(context, nodes)\n\n    result = result.mergeSorted(\n      sortedNodes,\n      createNodeSortComparator(sortFields)\n    )\n  }\n  const { limit, skip = 0 } = context\n\n  if (limit || skip) {\n    result = result.slice(skip, limit ? skip + limit : undefined)\n  }\n  return result\n}\n\nfunction runCountOnce(context: IQueryContext): number {\n  if (typeof context.totalCount === `undefined`) {\n    context.totalCount = runCount(context)\n  }\n  return context.totalCount\n}\n\nfunction runCount(context: IQueryContext): number {\n  let count = 0\n\n  if (!needsFiltering(context)) {\n    for (const typeName of context.nodeTypeNames) {\n      count += context.datastore.countNodes(typeName)\n    }\n    return count\n  }\n\n  if (!canUseIndex(context)) {\n    for (const typeName of context.nodeTypeNames) {\n      const nodes = completeFiltering(\n        context,\n        new GatsbyIterable(context.datastore.iterateNodesByType(typeName))\n      )\n      for (const _ of nodes) count++\n    }\n    return count\n  }\n\n  for (const typeName of context.nodeTypeNames) {\n    const indexMetadata = getIndexMetadata(\n      context,\n      typeName,\n      context.suggestedIndexFields\n    )\n    try {\n      count += countUsingIndexOnly({ ...context, indexMetadata })\n    } catch (e) {\n      // We cannot reliably count using index - fallback to full iteration :/\n      for (const _ of filterNodes(context, indexMetadata)) count++\n    }\n  }\n  return count\n}\n\nfunction performFullTableScan(\n  context: IQueryContext\n): GatsbyIterable<IGatsbyNode> {\n  // console.warn(`Fallback to full table scan :/`)\n\n  const { datastore, nodeTypeNames } = context\n\n  let result = new GatsbyIterable<IGatsbyNode>([])\n  for (const typeName of nodeTypeNames) {\n    let nodes = new GatsbyIterable(datastore.iterateNodesByType(typeName))\n    nodes = completeFiltering(context, nodes)\n\n    if (needsSorting(context)) {\n      nodes = sortNodesInMemory(context, nodes)\n      result = result.mergeSorted(\n        nodes,\n        createNodeSortComparator(context.sortFields)\n      )\n    } else {\n      result = result.concat(nodes)\n    }\n  }\n  const { limit, skip = 0 } = context\n\n  if (limit || skip) {\n    result = result.slice(skip, limit ? skip + limit : undefined)\n  }\n  return result\n}\n\nfunction filterNodes(\n  context: IQueryContext,\n  indexMetadata: IIndexMetadata\n): GatsbyIterable<IGatsbyNode> {\n  const { entries, usedQueries } = filterUsingIndex({\n    ...context,\n    indexMetadata,\n    reverse: Array.from(context.sortFields.values())[0] === -1,\n  })\n  const nodes = entries\n    .map(({ value }) => context.datastore.getNode(value))\n    .filter(Boolean)\n\n  return completeFiltering(\n    context,\n    nodes as GatsbyIterable<IGatsbyNode>,\n    usedQueries\n  )\n}\n\n/**\n * Takes intermediate result and applies any remaining filterQueries.\n *\n * If result is already fully filtered - simply returns.\n */\nfunction completeFiltering(\n  context: IQueryContext,\n  intermediateResult: GatsbyIterable<IGatsbyNode>,\n  usedQueries: Set<DbQuery> = new Set()\n): GatsbyIterable<IGatsbyNode> {\n  const { dbQueries } = context\n  if (isFullyFiltered(dbQueries, usedQueries)) {\n    return intermediateResult\n  }\n  // Apply remaining filter operations directly (last resort: slow)\n  const resolvedNodes = store.getState().resolvedNodesCache\n\n  const filtersToApply: Array<[string, IDbFilterStatement]> = dbQueries\n    .filter(q => !usedQueries.has(q))\n    .map(q => [dbQueryToDottedField(q), getFilterStatement(q)])\n\n  return intermediateResult.filter(node => {\n    const resolvedFields = resolvedNodes?.get(node.internal.type)?.get(node.id)\n\n    for (const [dottedField, filter] of filtersToApply) {\n      const tmp = resolveFieldValue(dottedField, node, resolvedFields)\n      const value = Array.isArray(tmp) ? tmp : [tmp]\n      if (value.some(v => !shouldFilter(filter, v))) {\n        // Mimic AND semantics\n        return false\n      }\n    }\n    return true\n  })\n}\n\nfunction sortNodesInMemory(\n  context: IQueryContext,\n  nodes: GatsbyIterable<IGatsbyNode>\n): GatsbyIterable<IGatsbyNode> {\n  // TODO: Sort using index data whenever possible (maybe store data needed for sorting in index values)\n  // TODO: Nodes can be partially sorted by index prefix - we can (and should) exploit this\n  return new GatsbyIterable(() => {\n    const arr = Array.from(nodes)\n    arr.sort(createNodeSortComparator(context.sortFields))\n    return arr\n  })\n}\n\nfunction createQueryContext(args: IDoRunQueryArgs): IQueryContext {\n  const { queryArgs: { filter, sort, limit, skip = 0 } = {}, firstOnly } = args\n\n  return {\n    datastore: args.datastore,\n    databases: args.databases,\n    nodeTypeNames: args.nodeTypeNames,\n    dbQueries: createDbQueriesFromObject(prepareQueryArgs(filter)),\n    sortFields: new Map<string, number>(\n      sort?.fields.map((field, i) => [field, isDesc(sort?.order[i]) ? -1 : 1])\n    ),\n    suggestedIndexFields: new Map(suggestIndex({ filter, sort })),\n    limit: firstOnly ? 1 : limit,\n    skip,\n  }\n}\n\nfunction canUseIndex(context: IQueryContext): boolean {\n  return context.suggestedIndexFields.size > 0\n}\n\nfunction needsFiltering(context: IQueryContext): boolean {\n  return context.dbQueries.length > 0\n}\n\nfunction needsSorting(context: IQueryContext): boolean {\n  return context.sortFields.size > 0\n}\n\n/**\n * Based on assumption that if all sort fields exist in index\n * then any result received from this index is fully sorted\n */\nfunction canUseIndexForSorting(\n  index: IIndexMetadata,\n  sortFields: SortFields\n): boolean {\n  const indexKeyFields = new Map(index.keyFields)\n  for (const [field, sortOrder] of sortFields) {\n    if (indexKeyFields.get(field) !== sortOrder) {\n      return false\n    }\n  }\n  return true\n}\n\nfunction isFullyFiltered(\n  dbQueries: Array<DbQuery>,\n  usedQueries: Set<DbQuery>\n): boolean {\n  return dbQueries.length === usedQueries.size\n}\n\nfunction getFilterById(context: IQueryContext): string | undefined {\n  for (const q of context.dbQueries) {\n    const filter = getFilterStatement(q)\n    if (\n      filter.comparator === DbComparator.EQ &&\n      dbQueryToDottedField(q) === `id`\n    ) {\n      return String(filter.value)\n    }\n  }\n  return undefined\n}\n\nfunction createNodeSortComparator(sortFields: SortFields): (a, b) => number {\n  const resolvedNodesCache = store.getState().resolvedNodesCache\n\n  return function nodeComparator(a: IGatsbyNode, b: IGatsbyNode): number {\n    const resolvedAFields = resolvedNodesCache?.get(a.internal.type)?.get(a.id)\n    const resolvedBFields = resolvedNodesCache?.get(b.internal.type)?.get(b.id)\n\n    for (const [field, direction] of sortFields) {\n      const valueA: any = resolveFieldValue(field, a, resolvedAFields)\n      const valueB: any = resolveFieldValue(field, b, resolvedBFields)\n\n      if (valueA > valueB) {\n        return direction === 1 ? 1 : -1\n      } else if (valueA < valueB) {\n        return direction === 1 ? -1 : 1\n      }\n    }\n    return 0\n  }\n}\n\nexport function compareByKeySuffix(prefixLength: number) {\n  return function (a: IIndexEntry, b: IIndexEntry): number {\n    const aSuffix = a.key.slice(prefixLength)\n    const bSuffix = b.key.slice(prefixLength)\n    // @ts-ignore\n    return compareKey(aSuffix, bSuffix)\n  }\n}\n"],"file":"run-query.js"}