{"version":3,"sources":["../../../../src/datastore/lmdb/query/filter-using-index.ts"],"names":["BinaryInfinityNegative","Buffer","from","BinaryInfinityPositive","String","fromCharCode","repeat","ValueEdges","filterUsingIndex","args","context","createFilteringContext","ranges","getIndexRanges","dbQueries","entries","GatsbyIterable","length","performRangeScan","performFullScan","usedQueries","size","narrowResultsIfPossible","isMultiKeyIndex","needsDeduplication","deduplicate","getIdentifier","countUsingIndexOnly","databases","indexes","indexMetadata","keyPrefix","Error","getKeysCount","start","end","getValueEdgeAfter","snapshot","count","Set","multiKeyFields","fieldsWithAppliedEq","forEach","q","filter","comparator","DbComparator","EQ","add","some","fieldName","has","stats","reverse","limit","skip","offset","maxKeysPerItem","range","getRange","undefinedSymbol","undefinedToEnd","topToUndefined","indexFields","Map","keyFields","positionInKey","set","filtersToApply","query","get","isNegatedQuery","push","key","fieldPositionInIndex","value","undefined","getSupportedRangeQueries","isSupported","IN","GTE","LTE","GT","LT","NIN","NE","supportedQueries","rangeStarts","rangeEndings","indexField","result","getIndexFieldRanges","rangeStartsProduct","rangeEndingsProduct","i","queries","sortDirection","fieldQueries","bestMatchingQuery","Array","isArray","arr","sort","a","b","hasNull","item","toIndexFieldValue","used","findRangeEdge","AFTER","rangeHead","rangeTail","predicate","edge","NONE","dbQuery","filterStatement","getValueEdgeBefore","filterValue","entry","id","out"],"mappings":"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","sourcesContent":["import { GatsbyIterable } from \"../../common/iterable\"\nimport {\n  DbComparator,\n  DbComparatorValue,\n  DbQuery,\n  dbQueryToDottedField,\n  getFilterStatement,\n  IDbFilterStatement,\n  sortBySpecificity,\n} from \"../../common/query\"\nimport { IDataStore, ILmdbDatabases, NodeId } from \"../../types\"\nimport {\n  IIndexMetadata,\n  IndexFieldValue,\n  IndexKey,\n  undefinedSymbol,\n} from \"./create-index\"\nimport { cartesianProduct, shouldFilter } from \"./common\"\nimport { inspect } from \"util\"\n\n// JS values encoded by ordered-binary never start with 0 or 255 byte\nexport const BinaryInfinityNegative = Buffer.from([0])\nexport const BinaryInfinityPositive = String.fromCharCode(255).repeat(4)\n\ntype RangeEdgeAfter = [IndexFieldValue, typeof BinaryInfinityPositive]\ntype RangeEdgeBefore = [typeof undefinedSymbol, IndexFieldValue]\ntype RangeValue =\n  | IndexFieldValue\n  | RangeEdgeAfter\n  | RangeEdgeBefore\n  | typeof BinaryInfinityPositive\n  | typeof BinaryInfinityNegative\ntype RangeBoundary = Array<RangeValue>\n\nexport interface IIndexEntry {\n  key: IndexKey\n  value: NodeId\n}\n\ninterface IIndexRange {\n  start: RangeBoundary\n  end: RangeBoundary\n}\n\nenum ValueEdges {\n  BEFORE = -1,\n  NONE = 0,\n  AFTER = 1,\n}\n\nexport interface IFilterArgs {\n  datastore: IDataStore\n  databases: ILmdbDatabases\n  dbQueries: Array<DbQuery>\n  indexMetadata: IIndexMetadata\n  limit?: number\n  skip?: number\n  reverse?: boolean\n}\n\ninterface IFilterContext extends IFilterArgs {\n  usedQueries: Set<DbQuery>\n}\n\nexport interface IFilterResult {\n  entries: GatsbyIterable<IIndexEntry>\n  usedQueries: Set<DbQuery>\n}\n\nexport function filterUsingIndex(args: IFilterArgs): IFilterResult {\n  const context = createFilteringContext(args)\n  const ranges = getIndexRanges(context, args.dbQueries)\n\n  let entries = new GatsbyIterable<IIndexEntry>(() =>\n    ranges.length > 0\n      ? performRangeScan(context, ranges)\n      : performFullScan(context)\n  )\n  if (context.usedQueries.size !== args.dbQueries.length) {\n    // Try to additionally filter out results using data stored in index\n    entries = narrowResultsIfPossible(context, entries)\n  }\n  if (isMultiKeyIndex(context) && needsDeduplication(context)) {\n    entries = entries.deduplicate(getIdentifier)\n  }\n  return { entries, usedQueries: context.usedQueries }\n}\n\nexport function countUsingIndexOnly(args: IFilterArgs): number {\n  const context = createFilteringContext(args)\n  const {\n    databases: { indexes },\n    dbQueries,\n    indexMetadata: { keyPrefix },\n  } = args\n\n  const ranges = getIndexRanges(context, args.dbQueries)\n\n  if (context.usedQueries.size !== dbQueries.length) {\n    throw new Error(`Cannot count using index only`)\n  }\n  if (isMultiKeyIndex(context) && needsDeduplication(context)) {\n    throw new Error(`Cannot count using MultiKey index.`)\n  }\n  if (ranges.length === 0) {\n    return indexes.getKeysCount({\n      start: [keyPrefix],\n      end: [getValueEdgeAfter(keyPrefix)],\n      snapshot: false,\n    } as any)\n  }\n  let count = 0\n  for (let { start, end } of ranges) {\n    start = [keyPrefix, ...start]\n    end = [keyPrefix, ...end]\n    // Assuming ranges are not overlapping\n    count += indexes.getKeysCount({ start, end, snapshot: false } as any)\n  }\n  return count\n}\n\nfunction createFilteringContext(args: IFilterArgs): IFilterContext {\n  return {\n    ...args,\n    usedQueries: new Set<DbQuery>(),\n  }\n}\n\nfunction isMultiKeyIndex(context: IFilterContext): boolean {\n  return context.indexMetadata.multiKeyFields.length > 0\n}\n\nfunction needsDeduplication(context: IFilterContext): boolean {\n  if (!isMultiKeyIndex(context)) {\n    return false\n  }\n  // Deduplication is not needed if all multiKeyFields have applied `eq` filters\n  const fieldsWithAppliedEq = new Set<string>()\n  context.usedQueries.forEach(q => {\n    const filter = getFilterStatement(q)\n    if (filter.comparator === DbComparator.EQ) {\n      fieldsWithAppliedEq.add(dbQueryToDottedField(q))\n    }\n  })\n  return context.indexMetadata.multiKeyFields.some(\n    fieldName => !fieldsWithAppliedEq.has(fieldName)\n  )\n}\n\nfunction* performRangeScan(\n  context: IFilterContext,\n  ranges: Array<IIndexRange>\n): Generator<IIndexEntry> {\n  const {\n    databases: { indexes },\n    indexMetadata: { keyPrefix, stats },\n    reverse,\n  } = context\n\n  let { limit, skip: offset = 0 } = context\n\n  if (limit) {\n    if (ranges.length > 1) {\n      // e.g. { in: [1, 2] }\n      // Cannot use offset: we will run several range queries and it's not clear which one to offset\n      // TODO: assuming ranges are sorted and not overlapping it should be possible to use offsets in this case\n      //   by running first range query, counting results while lazily iterating and\n      //   running the next range query when the previous iterator is done (and count is known)\n      //   with offset = offset - previousRangeCount, limit = limit - previousRangeCount\n      limit = offset + limit\n      offset = 0\n    }\n    if (isMultiKeyIndex(context) && needsDeduplication(context)) {\n      // Cannot use limit:\n      // MultiKey index may contain duplicates - we can only set a safe upper bound\n      limit *= stats.maxKeysPerItem\n    }\n  }\n  // Assuming ranges are sorted and not overlapping, we can yield results sequentially\n  for (let { start, end } of ranges) {\n    start = [keyPrefix, ...start]\n    end = [keyPrefix, ...end]\n    const range = !reverse\n      ? { start, end, limit, offset, snapshot: false }\n      : { start: end, end: start, limit, offset, reverse, snapshot: false }\n\n    // @ts-ignore\n    yield* indexes.getRange(range)\n  }\n}\n\nfunction* performFullScan(context: IFilterArgs): Generator<IIndexEntry> {\n  // *Caveat*: our old query implementation was putting undefined and null values at the end\n  //   of the list when ordered ascending. But lmdb-store keeps them at the top.\n  //   So in LMDB case, need to concat two ranges to conform to our old format:\n  //     concat(undefinedToEnd, topToUndefined)\n  const {\n    databases: { indexes },\n    reverse,\n    indexMetadata: { keyPrefix },\n  } = context\n\n  let start: RangeBoundary = [keyPrefix, getValueEdgeAfter(undefinedSymbol)]\n  let end: RangeBoundary = [getValueEdgeAfter(keyPrefix)]\n  let range = !reverse\n    ? { start, end, snapshot: false }\n    : { start: end, end: start, reverse, snapshot: false }\n\n  const undefinedToEnd = range\n\n  // Concat null/undefined values\n  end = start\n  start = [keyPrefix, null]\n  range = !reverse\n    ? { start, end, snapshot: false }\n    : { start: end, end: start, reverse, snapshot: false }\n\n  const topToUndefined = range\n\n  if (!reverse) {\n    // @ts-ignore\n    yield* indexes.getRange(undefinedToEnd)\n    // @ts-ignore\n    yield* indexes.getRange(topToUndefined)\n  } else {\n    // @ts-ignore\n    yield* indexes.getRange(topToUndefined)\n    // @ts-ignore\n    yield* indexes.getRange(undefinedToEnd)\n  }\n}\n\n/**\n * Takes results after the index scan and tries to filter them additionally with unused parts of the query.\n *\n * This is O(N) but the advantage is that it uses data available in the index.\n * So it effectively bypasses the `getNode()` call for such filters (with all associated deserialization complexity).\n *\n * Example:\n *   Imagine the index is: { foo: 1, bar: 1 }\n *\n * Now we run the query:\n *   sort: [`foo`]\n *   filter: { bar: { eq: `test` }}\n *\n * Initial filtering pass will have to perform a full index scan (because `bar` is the last field in the index).\n *\n * But we still have values of `bar` stored in the index itself,\n * so can filter by this value without loading the full node contents.\n */\nfunction narrowResultsIfPossible(\n  context: IFilterContext,\n  entries: GatsbyIterable<IIndexEntry>\n): GatsbyIterable<IIndexEntry> {\n  const { indexMetadata, dbQueries, usedQueries } = context\n\n  const indexFields = new Map<string, number>()\n  indexMetadata.keyFields.forEach(([fieldName], positionInKey) => {\n    // Every index key is [indexId, field1, field2, ...] and `indexMetadata.keyFields` contains [field1, field2, ...]\n    // As `indexId` is in the first column the fields need to be offset by +1 for correct addressing\n    indexFields.set(fieldName, positionInKey + 1)\n  })\n\n  type Filter = [filter: IDbFilterStatement, fieldPositionInIndex: number]\n  const filtersToApply: Array<Filter> = []\n\n  for (const query of dbQueries) {\n    const fieldName = dbQueryToDottedField(query)\n    const positionInKey = indexFields.get(fieldName)\n\n    if (typeof positionInKey === `undefined`) {\n      // No data for this field in index\n      continue\n    }\n    if (usedQueries.has(query)) {\n      // Filter is already applied\n      continue\n    }\n    if (isMultiKeyIndex(context) && isNegatedQuery(query)) {\n      // NE/NIN not supported with MultiKey indexes:\n      //   MultiKey indexes include duplicates; negated queries will only filter some of those\n      //   but may still incorrectly include others in final results\n      continue\n    }\n    const filter = getFilterStatement(query)\n    filtersToApply.push([filter, positionInKey])\n    usedQueries.add(query)\n  }\n\n  return filtersToApply.length === 0\n    ? entries\n    : entries.filter(({ key }) => {\n        for (const [filter, fieldPositionInIndex] of filtersToApply) {\n          const value =\n            key[fieldPositionInIndex] === undefinedSymbol\n              ? undefined\n              : key[fieldPositionInIndex]\n\n          if (!shouldFilter(filter, value)) {\n            // Mimic AND semantics\n            return false\n          }\n        }\n        return true\n      })\n}\n\n/**\n * Returns query clauses that can potentially use index.\n * Returned list is sorted by query specificity\n */\nfunction getSupportedRangeQueries(\n  context: IFilterContext,\n  dbQueries: Array<DbQuery>\n): Array<DbQuery> {\n  const isSupported = new Set([\n    DbComparator.EQ,\n    DbComparator.IN,\n    DbComparator.GTE,\n    DbComparator.LTE,\n    DbComparator.GT,\n    DbComparator.LT,\n    DbComparator.NIN,\n    DbComparator.NE,\n  ])\n  let supportedQueries = dbQueries.filter(query =>\n    isSupported.has(getFilterStatement(query).comparator)\n  )\n  if (isMultiKeyIndex(context)) {\n    // Note:\n    // NE and NIN are not supported by multi-key indexes. Why?\n    //   Imagine a node { id: 1, field: [`foo`, `bar`] }\n    //   Then the filter { field: { ne: `foo` } } should completely remove this node from results.\n    //   But multikey index contains separate entries for `foo` and `bar` values.\n    //   Final range will exclude entry \"foo\" but it will still include entry for \"bar\" hence\n    //   will incorrectly include our node in results.\n    supportedQueries = supportedQueries.filter(query => !isNegatedQuery(query))\n  }\n  return sortBySpecificity(supportedQueries)\n}\n\nfunction isNegatedQuery(query: DbQuery): boolean {\n  const filter = getFilterStatement(query)\n  return (\n    filter.comparator === DbComparator.NE ||\n    filter.comparator === DbComparator.NIN\n  )\n}\n\nexport function getIndexRanges(\n  context: IFilterContext,\n  dbQueries: Array<DbQuery>\n): Array<IIndexRange> {\n  const {\n    indexMetadata: { keyFields },\n  } = context\n  const rangeStarts: Array<RangeBoundary> = []\n  const rangeEndings: Array<RangeBoundary> = []\n  const supportedQueries = getSupportedRangeQueries(context, dbQueries)\n\n  for (const indexField of new Map(keyFields)) {\n    const result = getIndexFieldRanges(context, supportedQueries, indexField)\n\n    if (!result.rangeStarts.length) {\n      // No point to continue - just use index prefix, not all index fields\n      break\n    }\n    rangeStarts.push(result.rangeStarts)\n    rangeEndings.push(result.rangeEndings)\n  }\n  if (!rangeStarts.length) {\n    return []\n  }\n  // Example:\n  //   rangeStarts: [\n  //     [field1Start1, field1Start2],\n  //     [field2Start1],\n  //   ]\n  //   rangeEnds: [\n  //     [field1End1, field1End2],\n  //     [field2End1],\n  //   ]\n  // Need:\n  //   rangeStartsProduct: [\n  //     [field1Start1, field2Start1],\n  //     [field1Start2, field2Start1],\n  //   ]\n  //   rangeEndingsProduct: [\n  //     [field1End1, field2End1],\n  //     [field1End2, field2End1],\n  //   ]\n  const rangeStartsProduct = cartesianProduct(...rangeStarts)\n  const rangeEndingsProduct = cartesianProduct(...rangeEndings)\n\n  const ranges: Array<IIndexRange> = []\n  for (let i = 0; i < rangeStartsProduct.length; i++) {\n    ranges.push({\n      start: rangeStartsProduct[i],\n      end: rangeEndingsProduct[i],\n    })\n  }\n  // TODO: sort and intersect ranges. Also, we may want this at some point:\n  //   https://docs.mongodb.com/manual/core/multikey-index-bounds/\n  return ranges\n}\n\nfunction getIndexFieldRanges(\n  context: IFilterContext,\n  queries: Array<DbQuery>,\n  [indexField, sortDirection]: [fieldName: string, sortDirection: number]\n): {\n  rangeStarts: RangeBoundary\n  rangeEndings: RangeBoundary\n} {\n  // Tracking starts and ends separately instead of doing Array<[start, end]>\n  //  to simplify cartesian product creation later\n  const rangeStarts: RangeBoundary = []\n  const rangeEndings: RangeBoundary = []\n\n  const fieldQueries = queries.filter(\n    q => dbQueryToDottedField(q) === indexField\n  )\n  if (!fieldQueries.length) {\n    return { rangeStarts, rangeEndings }\n  }\n  // Assuming queries are sorted by specificity, the best bet is to pick the first query\n  // TODO: add range intersection for most common cases (e.g. gte + ne)\n  const bestMatchingQuery = fieldQueries[0]\n  const filter = getFilterStatement(bestMatchingQuery)\n\n  if (filter.comparator === DbComparator.IN && !Array.isArray(filter.value)) {\n    throw new Error(\"The argument to the `in` predicate should be an array\")\n  }\n\n  context.usedQueries.add(bestMatchingQuery)\n\n  switch (filter.comparator) {\n    case DbComparator.EQ:\n    case DbComparator.IN: {\n      const arr = Array.isArray(filter.value)\n        ? [...filter.value]\n        : [filter.value]\n\n      // Sort ranges by index sort direction\n      arr.sort((a: any, b: any): number => {\n        if (a === b) return 0\n        if (sortDirection === 1) return a > b ? 1 : -1\n        return a < b ? 1 : -1\n      })\n      // TODO: ideally do range intersections with other queries (e.g. $in + $gt + $lt)\n      //  although it is likely something like 0.1% of cases\n      //  (right now it applies additional filters in runQuery.completeFiltering)\n\n      let hasNull = false\n      for (const item of new Set(arr)) {\n        const value = toIndexFieldValue(item, filter)\n        if (value === null) hasNull = true\n        rangeStarts.push(value)\n        rangeEndings.push(getValueEdgeAfter(value))\n      }\n      // Special case: { eq: null } or { in: [null, `any`]} must also include values for undefined!\n      if (hasNull) {\n        rangeStarts.push(undefinedSymbol)\n        rangeEndings.push(getValueEdgeAfter(undefinedSymbol))\n      }\n      break\n    }\n    case DbComparator.LT:\n    case DbComparator.LTE: {\n      if (Array.isArray(filter.value))\n        throw new Error(`${filter.comparator} value must not be an array`)\n\n      const value = toIndexFieldValue(filter.value, filter)\n      const end =\n        filter.comparator === DbComparator.LT ? value : getValueEdgeAfter(value)\n\n      // Try to find matching GTE/GT filter\n      const used = context.usedQueries\n      const start =\n        findRangeEdge(fieldQueries, used, DbComparator.GTE) ??\n        findRangeEdge(fieldQueries, used, DbComparator.GT, ValueEdges.AFTER)\n\n      // Do not include null or undefined in results unless null was requested explicitly\n      //\n      // Index ordering:\n      //  BinaryInfinityNegative\n      //  null\n      //  Symbol(`undef`)\n      //  -10\n      //  10\n      //  `Hello`\n      //  [`Hello`]\n      //  BinaryInfinityPositive\n      const rangeHead =\n        value === null\n          ? BinaryInfinityNegative\n          : getValueEdgeAfter(undefinedSymbol)\n\n      rangeStarts.push(start ?? rangeHead)\n      rangeEndings.push(end)\n      break\n    }\n    case DbComparator.GT:\n    case DbComparator.GTE: {\n      if (Array.isArray(filter.value))\n        throw new Error(`${filter.comparator} value must not be an array`)\n\n      const value = toIndexFieldValue(filter.value, filter)\n      const start =\n        filter.comparator === DbComparator.GTE\n          ? value\n          : getValueEdgeAfter(value)\n\n      // Try to find matching LT/LTE\n      const used = context.usedQueries\n      const end =\n        findRangeEdge(fieldQueries, used, DbComparator.LTE, ValueEdges.AFTER) ??\n        findRangeEdge(fieldQueries, used, DbComparator.LT)\n\n      const rangeTail =\n        value === null ? getValueEdgeAfter(null) : BinaryInfinityPositive\n\n      rangeStarts.push(start)\n      rangeEndings.push(end ?? rangeTail)\n      break\n    }\n    case DbComparator.NE:\n    case DbComparator.NIN: {\n      const arr = Array.isArray(filter.value)\n        ? [...filter.value]\n        : [filter.value]\n\n      // Sort ranges by index sort direction\n      arr.sort((a: any, b: any): number => {\n        if (a === b) return 0\n        if (sortDirection === 1) return a > b ? 1 : -1\n        return a < b ? 1 : -1\n      })\n      const hasNull = arr.some(value => value === null)\n\n      if (hasNull) {\n        rangeStarts.push(getValueEdgeAfter(undefinedSymbol))\n      } else {\n        rangeStarts.push(BinaryInfinityNegative)\n      }\n      for (const item of new Set(arr)) {\n        const value = toIndexFieldValue(item, filter)\n        if (value === null) continue // already handled via hasNull case above\n        rangeEndings.push(value)\n        rangeStarts.push(getValueEdgeAfter(value))\n      }\n      rangeEndings.push(BinaryInfinityPositive)\n      break\n    }\n    default:\n      throw new Error(`Unsupported predicate: ${filter.comparator}`)\n  }\n  return { rangeStarts, rangeEndings }\n}\n\nfunction findRangeEdge(\n  queries: Array<DbQuery>,\n  usedQueries: Set<DbQuery>,\n  predicate: DbComparator,\n  edge: ValueEdges = ValueEdges.NONE\n): IndexFieldValue | RangeEdgeBefore | RangeEdgeAfter | undefined {\n  for (const dbQuery of queries) {\n    if (usedQueries.has(dbQuery)) {\n      continue\n    }\n    const filterStatement = getFilterStatement(dbQuery)\n    if (filterStatement.comparator !== predicate) {\n      continue\n    }\n    usedQueries.add(dbQuery)\n    const value = filterStatement.value\n    if (Array.isArray(value)) {\n      throw new Error(`Range filter ${predicate} should not have array value`)\n    }\n    if (typeof value === `object` && value !== null) {\n      throw new Error(\n        `Range filter ${predicate} should not have value of type ${typeof value}`\n      )\n    }\n    if (edge === 0) {\n      return value\n    }\n    return edge < 0 ? getValueEdgeBefore(value) : getValueEdgeAfter(value)\n  }\n  return undefined\n}\n\n/**\n * Returns the edge after the given value, suitable for lmdb range queries.\n *\n * Example:\n * Get all items from index starting with [\"foo\"] prefix up to the next existing prefix:\n *\n * ```js\n *   db.getRange({ start: [\"foo\"], end: [getValueEdgeAfter(\"foo\")] })\n * ```\n *\n * This method relies on ordered-binary format used by lmdb-store to persist keys\n * and assumes keys are composite and represented as arrays.\n *\n * Implementation detail: ordered-binary treats `null` as multipart separator within binary sequence\n */\nfunction getValueEdgeAfter(value: IndexFieldValue): RangeEdgeAfter {\n  return [value, BinaryInfinityPositive]\n}\nfunction getValueEdgeBefore(value: IndexFieldValue): RangeEdgeBefore {\n  return [undefinedSymbol, value]\n}\n\nfunction toIndexFieldValue(\n  filterValue: DbComparatorValue,\n  filter: IDbFilterStatement\n): IndexFieldValue {\n  if (typeof filterValue === `object` && filterValue !== null) {\n    throw new Error(\n      `Bad filter value for predicate ${filter.comparator}: ${inspect(\n        filter.value\n      )}`\n    )\n  }\n  return filterValue\n}\n\nfunction getIdentifier(entry: IIndexEntry): number | string {\n  const id = entry.key[entry.key.length - 1]\n  if (typeof id !== `number` && typeof id !== `string`) {\n    const out = inspect(id)\n    throw new Error(\n      `Last element of index key is expected to be numeric or string id, got ${out}`\n    )\n  }\n  return id\n}\n"],"file":"filter-using-index.js"}