{"version":3,"sources":["../../../../src/datastore/lmdb/query/suggest-index.ts"],"names":["suggestIndex","filter","sort","maxFields","filterQueries","filterQueriesThatCanUseIndex","getQueriesThatCanUseIndex","sortFields","getSortFieldsThatCanUseIndex","length","dedupeAndTrim","toIndexFields","overlap","findOverlappingFields","size","eqFields","getFieldsWithEqPredicate","eqFilterFields","map","f","comparator","DbComparator","IN","filterFields","q","name","has","canUseIndex","Set","EQ","GTE","LTE","GT","LT","NIN","NE","all","querySortArg","fields","order","initialOrder","i","field","push","fieldName","filterQuery","find","add","queries","Map","slice"],"mappings":"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","sourcesContent":["import { IRunQueryArgs } from \"../../types\"\nimport {\n  createDbQueriesFromObject,\n  DbComparator,\n  DbQuery,\n  dbQueryToDottedField,\n  getFilterStatement,\n  prepareQueryArgs,\n  sortBySpecificity,\n} from \"../../common/query\"\nimport { isDesc } from \"./common\"\n\ninterface ISelectIndexArgs {\n  filter: IRunQueryArgs[\"queryArgs\"][\"filter\"]\n  sort: IRunQueryArgs[\"queryArgs\"][\"sort\"]\n  maxFields?: number\n}\n\ntype IndexField = [fieldName: string, orderDirection: number]\ntype IndexFields = Array<IndexField>\n\nexport function suggestIndex({\n  filter,\n  sort,\n  maxFields = 4,\n}: ISelectIndexArgs): Array<IndexField> {\n  const filterQueries = createDbQueriesFromObject(prepareQueryArgs(filter))\n  const filterQueriesThatCanUseIndex = getQueriesThatCanUseIndex(filterQueries)\n  const sortFields: Array<IndexField> = getSortFieldsThatCanUseIndex(sort)\n\n  if (!sortFields.length && !filterQueriesThatCanUseIndex.length) {\n    return []\n  }\n  if (!filterQueriesThatCanUseIndex.length) {\n    return dedupeAndTrim(sortFields, maxFields)\n  }\n  if (!sortFields.length) {\n    return dedupeAndTrim(toIndexFields(filterQueriesThatCanUseIndex), maxFields)\n  }\n  const overlap = findOverlappingFields(\n    filterQueriesThatCanUseIndex,\n    sortFields\n  )\n  if (!overlap.size) {\n    // Filter and sort fields do not overlap.\n    // In this case combined index for filter+sort only makes sense when all filters have `eq` predicate\n    // Same as https://docs.mongodb.com/manual/tutorial/sort-results-with-indexes/#sort-and-non-prefix-subset-of-an-index\n    const eqFields = getFieldsWithEqPredicate(filterQueriesThatCanUseIndex)\n\n    if (eqFields.size === filterQueriesThatCanUseIndex.length) {\n      const eqFilterFields: Array<IndexField> = [...eqFields].map(f => [f, 1])\n      return dedupeAndTrim([...eqFilterFields, ...sortFields], maxFields)\n    }\n    // Single unbound range filter: \"lt\", \"gt\", \"gte\", \"lte\" (but not \"in\"): prefer sort fields\n    if (\n      filterQueriesThatCanUseIndex.length === 1 &&\n      getFilterStatement(filterQueriesThatCanUseIndex[0]).comparator !==\n        DbComparator.IN\n    ) {\n      return dedupeAndTrim(sortFields, maxFields)\n    }\n    // Otherwise prefer filter fields\n    return dedupeAndTrim(toIndexFields(filterQueriesThatCanUseIndex), maxFields)\n  }\n\n  // There is an overlap:\n  // First add all non-overlapping filter fields to index prefix, then all sort fields (including overlapping)\n  const filterFields = filterQueriesThatCanUseIndex\n    .map((q): IndexField => [dbQueryToDottedField(q), 1])\n    .filter(([name]) => !overlap.has(name))\n\n  return dedupeAndTrim([...filterFields, ...sortFields], maxFields)\n}\n\nconst canUseIndex = new Set([\n  DbComparator.EQ,\n  DbComparator.IN,\n  DbComparator.GTE,\n  DbComparator.LTE,\n  DbComparator.GT,\n  DbComparator.LT,\n  DbComparator.NIN,\n  DbComparator.NE,\n])\n\n/**\n * Returns queries that can potentially use index.\n * Returned list is sorted by query specificity\n */\nfunction getQueriesThatCanUseIndex(all: Array<DbQuery>): Array<DbQuery> {\n  return sortBySpecificity(\n    all.filter(q => canUseIndex.has(getFilterStatement(q).comparator))\n  )\n}\n\nfunction getSortFieldsThatCanUseIndex(\n  querySortArg: IRunQueryArgs[\"queryArgs\"][\"sort\"]\n): Array<IndexField> {\n  const sort = querySortArg || { fields: [], order: [] }\n  const initialOrder = isDesc(sort?.order[0]) ? -1 : 1\n\n  const sortFields: Array<IndexField> = []\n  for (let i = 0; i < sort.fields.length; i++) {\n    const field = sort.fields[i]\n    const order = isDesc(sort.order[i]) ? -1 : 1\n    if (order !== initialOrder) {\n      // Mixed sort order is not supported by our indexes yet :/\n      // See https://github.com/DoctorEvidence/lmdb-store/discussions/62#discussioncomment-898949\n      break\n    }\n    sortFields.push([field, order])\n  }\n  return sortFields\n}\n\nfunction findOverlappingFields(\n  filterQueries: Array<DbQuery>,\n  sortFields: Array<IndexField>\n): Set<string> {\n  const overlap = new Set<string>()\n\n  for (const [fieldName] of sortFields) {\n    const filterQuery = filterQueries.find(\n      q => dbQueryToDottedField(q) === fieldName\n    )\n    if (!filterQuery) {\n      break\n    }\n    overlap.add(fieldName)\n  }\n  return overlap\n}\n\nfunction getFieldsWithEqPredicate(filterQueries: Array<DbQuery>): Set<string> {\n  return new Set<string>(\n    filterQueries\n      .filter(\n        filterQuery =>\n          getFilterStatement(filterQuery).comparator === DbComparator.EQ\n      )\n      .map(filterQuery => dbQueryToDottedField(filterQuery))\n  )\n}\n\nfunction toIndexFields(queries: Array<DbQuery>): IndexFields {\n  return queries.map((q): IndexField => [dbQueryToDottedField(q), 1])\n}\n\nfunction dedupeAndTrim(fields: IndexFields, maxFields: number): IndexFields {\n  return [...new Map(fields)].slice(0, maxFields)\n}\n"],"file":"suggest-index.js"}