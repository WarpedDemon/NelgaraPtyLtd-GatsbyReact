"use strict";

exports.__esModule = true;
exports.suggestIndex = suggestIndex;

var _query = require("../../common/query");

var _common = require("./common");

function suggestIndex({
  filter,
  sort,
  maxFields = 4
}) {
  const filterQueries = (0, _query.createDbQueriesFromObject)((0, _query.prepareQueryArgs)(filter));
  const filterQueriesThatCanUseIndex = getQueriesThatCanUseIndex(filterQueries);
  const sortFields = getSortFieldsThatCanUseIndex(sort);

  if (!sortFields.length && !filterQueriesThatCanUseIndex.length) {
    return [];
  }

  if (!filterQueriesThatCanUseIndex.length) {
    return dedupeAndTrim(sortFields, maxFields);
  }

  if (!sortFields.length) {
    return dedupeAndTrim(toIndexFields(filterQueriesThatCanUseIndex), maxFields);
  }

  const overlap = findOverlappingFields(filterQueriesThatCanUseIndex, sortFields);

  if (!overlap.size) {
    // Filter and sort fields do not overlap.
    // In this case combined index for filter+sort only makes sense when all filters have `eq` predicate
    // Same as https://docs.mongodb.com/manual/tutorial/sort-results-with-indexes/#sort-and-non-prefix-subset-of-an-index
    const eqFields = getFieldsWithEqPredicate(filterQueriesThatCanUseIndex);

    if (eqFields.size === filterQueriesThatCanUseIndex.length) {
      const eqFilterFields = [...eqFields].map(f => [f, 1]);
      return dedupeAndTrim([...eqFilterFields, ...sortFields], maxFields);
    } // Single unbound range filter: "lt", "gt", "gte", "lte" (but not "in"): prefer sort fields


    if (filterQueriesThatCanUseIndex.length === 1 && (0, _query.getFilterStatement)(filterQueriesThatCanUseIndex[0]).comparator !== _query.DbComparator.IN) {
      return dedupeAndTrim(sortFields, maxFields);
    } // Otherwise prefer filter fields


    return dedupeAndTrim(toIndexFields(filterQueriesThatCanUseIndex), maxFields);
  } // There is an overlap:
  // First add all non-overlapping filter fields to index prefix, then all sort fields (including overlapping)


  const filterFields = filterQueriesThatCanUseIndex.map(q => [(0, _query.dbQueryToDottedField)(q), 1]).filter(([name]) => !overlap.has(name));
  return dedupeAndTrim([...filterFields, ...sortFields], maxFields);
}

const canUseIndex = new Set([_query.DbComparator.EQ, _query.DbComparator.IN, _query.DbComparator.GTE, _query.DbComparator.LTE, _query.DbComparator.GT, _query.DbComparator.LT, _query.DbComparator.NIN, _query.DbComparator.NE]);
/**
 * Returns queries that can potentially use index.
 * Returned list is sorted by query specificity
 */

function getQueriesThatCanUseIndex(all) {
  return (0, _query.sortBySpecificity)(all.filter(q => canUseIndex.has((0, _query.getFilterStatement)(q).comparator)));
}

function getSortFieldsThatCanUseIndex(querySortArg) {
  const sort = querySortArg || {
    fields: [],
    order: []
  };
  const initialOrder = (0, _common.isDesc)(sort === null || sort === void 0 ? void 0 : sort.order[0]) ? -1 : 1;
  const sortFields = [];

  for (let i = 0; i < sort.fields.length; i++) {
    const field = sort.fields[i];
    const order = (0, _common.isDesc)(sort.order[i]) ? -1 : 1;

    if (order !== initialOrder) {
      // Mixed sort order is not supported by our indexes yet :/
      // See https://github.com/DoctorEvidence/lmdb-store/discussions/62#discussioncomment-898949
      break;
    }

    sortFields.push([field, order]);
  }

  return sortFields;
}

function findOverlappingFields(filterQueries, sortFields) {
  const overlap = new Set();

  for (const [fieldName] of sortFields) {
    const filterQuery = filterQueries.find(q => (0, _query.dbQueryToDottedField)(q) === fieldName);

    if (!filterQuery) {
      break;
    }

    overlap.add(fieldName);
  }

  return overlap;
}

function getFieldsWithEqPredicate(filterQueries) {
  return new Set(filterQueries.filter(filterQuery => (0, _query.getFilterStatement)(filterQuery).comparator === _query.DbComparator.EQ).map(filterQuery => (0, _query.dbQueryToDottedField)(filterQuery)));
}

function toIndexFields(queries) {
  return queries.map(q => [(0, _query.dbQueryToDottedField)(q), 1]);
}

function dedupeAndTrim(fields, maxFields) {
  return [...new Map(fields)].slice(0, maxFields);
}
//# sourceMappingURL=suggest-index.js.map