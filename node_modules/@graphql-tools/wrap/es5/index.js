'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const tslib = require('tslib');
const graphql = require('graphql');
const utils = require('@graphql-tools/utils/es5');
const delegate = require('@graphql-tools/delegate/es5');
const valueOrPromise = require('value-or-promise');

function generateProxyingResolvers(subschemaConfig) {
    var e_1, _a;
    var _b;
    var targetSchema = subschemaConfig.schema;
    var createProxyingResolver = (_b = subschemaConfig.createProxyingResolver) !== null && _b !== void 0 ? _b : defaultCreateProxyingResolver;
    var transformedSchema = delegate.applySchemaTransforms(targetSchema, subschemaConfig);
    var rootTypeMap = utils.getRootTypeMap(targetSchema);
    var resolvers = {};
    try {
        for (var _c = tslib.__values(rootTypeMap.entries()), _d = _c.next(); !_d.done; _d = _c.next()) {
            var _e = tslib.__read(_d.value, 2), operation = _e[0], rootType = _e[1];
            var typeName = rootType.name;
            var fields = rootType.getFields();
            resolvers[typeName] = {};
            for (var fieldName in fields) {
                var proxyingResolver = createProxyingResolver({
                    subschemaConfig: subschemaConfig,
                    transformedSchema: transformedSchema,
                    operation: operation,
                    fieldName: fieldName,
                });
                var finalResolver = createPossiblyNestedProxyingResolver(subschemaConfig, proxyingResolver);
                if (operation === 'subscription') {
                    resolvers[typeName][fieldName] = {
                        subscribe: finalResolver,
                        resolve: identical,
                    };
                }
                else {
                    resolvers[typeName][fieldName] = {
                        resolve: finalResolver,
                    };
                }
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return resolvers;
}
function identical(value) {
    return value;
}
function createPossiblyNestedProxyingResolver(subschemaConfig, proxyingResolver) {
    return function possiblyNestedProxyingResolver(parent, args, context, info) {
        if (parent != null) {
            var responseKey = utils.getResponseKeyFromInfo(info);
            // Check to see if the parent contains a proxied result
            if (delegate.isExternalObject(parent)) {
                var unpathedErrors = delegate.getUnpathedErrors(parent);
                var subschema = delegate.getSubschema(parent, responseKey);
                // If there is a proxied result from this subschema, return it
                // This can happen even for a root field when the root type ia
                // also nested as a field within a different type.
                if (subschemaConfig === subschema && parent[responseKey] !== undefined) {
                    return delegate.resolveExternalValue(parent[responseKey], unpathedErrors, subschema, context, info);
                }
            }
        }
        return proxyingResolver(parent, args, context, info);
    };
}
function defaultCreateProxyingResolver(_a) {
    var subschemaConfig = _a.subschemaConfig, operation = _a.operation, transformedSchema = _a.transformedSchema;
    return function proxyingResolver(_parent, _args, context, info) {
        return delegate.delegateToSchema({
            schema: subschemaConfig,
            operation: operation,
            context: context,
            info: info,
            transformedSchema: transformedSchema,
        });
    };
}

function wrapSchema(subschemaConfig) {
    var targetSchema = subschemaConfig.schema;
    var proxyingResolvers = generateProxyingResolvers(subschemaConfig);
    var schema = createWrappingSchema(targetSchema, proxyingResolvers);
    var transformedSchema = delegate.applySchemaTransforms(schema, subschemaConfig);
    return delegate.applySchemaTransforms(schema, subschemaConfig, transformedSchema);
}
function createWrappingSchema(schema, proxyingResolvers) {
    var _a;
    return utils.mapSchema(schema, (_a = {},
        _a[utils.MapperKind.ROOT_OBJECT] = function (type) {
            var _a;
            var config = type.toConfig();
            var fieldConfigMap = config.fields;
            for (var fieldName in fieldConfigMap) {
                var field = fieldConfigMap[fieldName];
                if (field == null) {
                    continue;
                }
                fieldConfigMap[fieldName] = tslib.__assign(tslib.__assign({}, field), (_a = proxyingResolvers[type.name]) === null || _a === void 0 ? void 0 : _a[fieldName]);
            }
            return new graphql.GraphQLObjectType(config);
        },
        _a[utils.MapperKind.OBJECT_TYPE] = function (type) {
            var config = type.toConfig();
            config.isTypeOf = undefined;
            for (var fieldName in config.fields) {
                var field = config.fields[fieldName];
                if (field == null) {
                    continue;
                }
                field.resolve = delegate.defaultMergedResolver;
                field.subscribe = undefined;
            }
            return new graphql.GraphQLObjectType(config);
        },
        _a[utils.MapperKind.INTERFACE_TYPE] = function (type) {
            var config = type.toConfig();
            delete config.resolveType;
            return new graphql.GraphQLInterfaceType(config);
        },
        _a[utils.MapperKind.UNION_TYPE] = function (type) {
            var config = type.toConfig();
            delete config.resolveType;
            return new graphql.GraphQLUnionType(config);
        },
        _a));
}

var RenameTypes = /** @class */ (function () {
    function RenameTypes(renamer, options) {
        this.renamer = renamer;
        this.map = Object.create(null);
        this.reverseMap = Object.create(null);
        var _a = options != null ? options : {}, _b = _a.renameBuiltins, renameBuiltins = _b === void 0 ? false : _b, _c = _a.renameScalars, renameScalars = _c === void 0 ? true : _c;
        this.renameBuiltins = renameBuiltins;
        this.renameScalars = renameScalars;
    }
    RenameTypes.prototype.transformSchema = function (originalWrappingSchema, _subschemaConfig, _transformedSchema) {
        var _a;
        var _this = this;
        return utils.mapSchema(originalWrappingSchema, (_a = {},
            _a[utils.MapperKind.TYPE] = function (type) {
                if (graphql.isSpecifiedScalarType(type) && !_this.renameBuiltins) {
                    return undefined;
                }
                if (graphql.isScalarType(type) && !_this.renameScalars) {
                    return undefined;
                }
                var oldName = type.name;
                var newName = _this.renamer(oldName);
                if (newName !== undefined && newName !== oldName) {
                    _this.map[oldName] = newName;
                    _this.reverseMap[newName] = oldName;
                    return utils.renameType(type, newName);
                }
            },
            _a[utils.MapperKind.ROOT_OBJECT] = function () {
                return undefined;
            },
            _a));
    };
    RenameTypes.prototype.transformRequest = function (originalRequest, _delegationContext, _transformationContext) {
        var _a;
        var _this = this;
        var document = graphql.visit(originalRequest.document, (_a = {},
            _a[graphql.Kind.NAMED_TYPE] = function (node) {
                var name = node.name.value;
                if (name in _this.reverseMap) {
                    return tslib.__assign(tslib.__assign({}, node), { name: {
                            kind: graphql.Kind.NAME,
                            value: _this.reverseMap[name],
                        } });
                }
            },
            _a));
        return tslib.__assign(tslib.__assign({}, originalRequest), { document: document });
    };
    RenameTypes.prototype.transformResult = function (originalResult, _delegationContext, _transformationContext) {
        var _this = this;
        return tslib.__assign(tslib.__assign({}, originalResult), { data: utils.visitData(originalResult.data, function (object) {
                var typeName = object === null || object === void 0 ? void 0 : object.__typename;
                if (typeName != null && typeName in _this.map) {
                    object.__typename = _this.map[typeName];
                }
                return object;
            }) });
    };
    return RenameTypes;
}());

var FilterTypes = /** @class */ (function () {
    function FilterTypes(filter) {
        this.filter = filter;
    }
    FilterTypes.prototype.transformSchema = function (originalWrappingSchema, _subschemaConfig, _transformedSchema) {
        var _a;
        var _this = this;
        return utils.mapSchema(originalWrappingSchema, (_a = {},
            _a[utils.MapperKind.TYPE] = function (type) {
                if (_this.filter(type)) {
                    return undefined;
                }
                return null;
            },
            _a));
    };
    return FilterTypes;
}());

var RenameRootTypes = /** @class */ (function () {
    function RenameRootTypes(renamer) {
        this.renamer = renamer;
        this.map = Object.create(null);
        this.reverseMap = Object.create(null);
    }
    RenameRootTypes.prototype.transformSchema = function (originalWrappingSchema, _subschemaConfig, _transformedSchema) {
        var _a;
        var _this = this;
        return utils.mapSchema(originalWrappingSchema, (_a = {},
            _a[utils.MapperKind.ROOT_OBJECT] = function (type) {
                var oldName = type.name;
                var newName = _this.renamer(oldName);
                if (newName !== undefined && newName !== oldName) {
                    _this.map[oldName] = newName;
                    _this.reverseMap[newName] = oldName;
                    return utils.renameType(type, newName);
                }
            },
            _a));
    };
    RenameRootTypes.prototype.transformRequest = function (originalRequest, _delegationContext, _transformationContext) {
        var _a;
        var _this = this;
        var document = graphql.visit(originalRequest.document, (_a = {},
            _a[graphql.Kind.NAMED_TYPE] = function (node) {
                var name = node.name.value;
                if (name in _this.reverseMap) {
                    return tslib.__assign(tslib.__assign({}, node), { name: {
                            kind: graphql.Kind.NAME,
                            value: _this.reverseMap[name],
                        } });
                }
            },
            _a));
        return tslib.__assign(tslib.__assign({}, originalRequest), { document: document });
    };
    RenameRootTypes.prototype.transformResult = function (originalResult, _delegationContext, _transformationContext) {
        var _this = this;
        return tslib.__assign(tslib.__assign({}, originalResult), { data: utils.visitData(originalResult.data, function (object) {
                var typeName = object === null || object === void 0 ? void 0 : object.__typename;
                if (typeName != null && typeName in _this.map) {
                    object.__typename = _this.map[typeName];
                }
                return object;
            }) });
    };
    return RenameRootTypes;
}());

var TransformCompositeFields = /** @class */ (function () {
    function TransformCompositeFields(fieldTransformer, fieldNodeTransformer, dataTransformer, errorsTransformer) {
        this.fieldTransformer = fieldTransformer;
        this.fieldNodeTransformer = fieldNodeTransformer;
        this.dataTransformer = dataTransformer;
        this.errorsTransformer = errorsTransformer;
        this.mapping = {};
    }
    TransformCompositeFields.prototype._getTypeInfo = function () {
        var typeInfo = this.typeInfo;
        if (typeInfo === undefined) {
            throw new Error("The TransformCompositeFields transform's  \"transformRequest\" and \"transformResult\" methods cannot be used without first calling \"transformSchema\".");
        }
        return typeInfo;
    };
    TransformCompositeFields.prototype.transformSchema = function (originalWrappingSchema, _subschemaConfig, _transformedSchema) {
        var _a;
        var _this = this;
        var _b;
        this.transformedSchema = utils.mapSchema(originalWrappingSchema, (_a = {},
            _a[utils.MapperKind.COMPOSITE_FIELD] = function (fieldConfig, fieldName, typeName) {
                var transformedField = _this.fieldTransformer(typeName, fieldName, fieldConfig);
                if (Array.isArray(transformedField)) {
                    var newFieldName = transformedField[0];
                    if (newFieldName !== fieldName) {
                        if (!(typeName in _this.mapping)) {
                            _this.mapping[typeName] = {};
                        }
                        _this.mapping[typeName][newFieldName] = fieldName;
                    }
                }
                return transformedField;
            },
            _a));
        this.typeInfo = new graphql.TypeInfo(this.transformedSchema);
        this.subscriptionTypeName = (_b = originalWrappingSchema.getSubscriptionType()) === null || _b === void 0 ? void 0 : _b.name;
        return this.transformedSchema;
    };
    TransformCompositeFields.prototype.transformRequest = function (originalRequest, _delegationContext, transformationContext) {
        var document = originalRequest.document;
        return tslib.__assign(tslib.__assign({}, originalRequest), { document: this.transformDocument(document, transformationContext) });
    };
    TransformCompositeFields.prototype.transformResult = function (result, _delegationContext, transformationContext) {
        var dataTransformer = this.dataTransformer;
        if (dataTransformer != null) {
            result.data = utils.visitData(result.data, function (value) { return dataTransformer(value, transformationContext); });
        }
        if (this.errorsTransformer != null && Array.isArray(result.errors)) {
            result.errors = this.errorsTransformer(result.errors, transformationContext);
        }
        return result;
    };
    TransformCompositeFields.prototype.transformDocument = function (document, transformationContext) {
        var e_1, _a, _b;
        var _this = this;
        var fragments = Object.create(null);
        try {
            for (var _c = tslib.__values(document.definitions), _d = _c.next(); !_d.done; _d = _c.next()) {
                var def = _d.value;
                if (def.kind === graphql.Kind.FRAGMENT_DEFINITION) {
                    fragments[def.name.value] = def;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return graphql.visit(document, graphql.visitWithTypeInfo(this._getTypeInfo(), {
            leave: (_b = {},
                _b[graphql.Kind.SELECTION_SET] = function (node) {
                    return _this.transformSelectionSet(node, _this._getTypeInfo(), fragments, transformationContext);
                },
                _b),
        }));
    };
    TransformCompositeFields.prototype.transformSelectionSet = function (node, typeInfo, fragments, transformationContext) {
        var e_2, _a;
        var _b, _c;
        var parentType = typeInfo.getParentType();
        if (parentType == null) {
            return undefined;
        }
        var parentTypeName = parentType.name;
        var newSelections = [];
        try {
            for (var _d = tslib.__values(node.selections), _e = _d.next(); !_e.done; _e = _d.next()) {
                var selection = _e.value;
                if (selection.kind !== graphql.Kind.FIELD) {
                    newSelections.push(selection);
                    continue;
                }
                var newName = selection.name.value;
                // See https://github.com/ardatan/graphql-tools/issues/2282
                if ((this.dataTransformer != null || this.errorsTransformer != null) &&
                    (this.subscriptionTypeName == null || parentTypeName !== this.subscriptionTypeName)) {
                    newSelections.push({
                        kind: graphql.Kind.FIELD,
                        name: {
                            kind: graphql.Kind.NAME,
                            value: '__typename',
                        },
                    });
                }
                var transformedSelection = void 0;
                if (this.fieldNodeTransformer == null) {
                    transformedSelection = selection;
                }
                else {
                    transformedSelection = this.fieldNodeTransformer(parentTypeName, newName, selection, fragments, transformationContext);
                    transformedSelection = transformedSelection === undefined ? selection : transformedSelection;
                }
                if (transformedSelection == null) {
                    continue;
                }
                else if (Array.isArray(transformedSelection)) {
                    newSelections = newSelections.concat(transformedSelection);
                    continue;
                }
                else if (transformedSelection.kind !== graphql.Kind.FIELD) {
                    newSelections.push(transformedSelection);
                    continue;
                }
                var typeMapping = this.mapping[parentTypeName];
                if (typeMapping == null) {
                    newSelections.push(transformedSelection);
                    continue;
                }
                var oldName = this.mapping[parentTypeName][newName];
                if (oldName == null) {
                    newSelections.push(transformedSelection);
                    continue;
                }
                newSelections.push(tslib.__assign(tslib.__assign({}, transformedSelection), { name: {
                        kind: graphql.Kind.NAME,
                        value: oldName,
                    }, alias: {
                        kind: graphql.Kind.NAME,
                        value: (_c = (_b = transformedSelection.alias) === null || _b === void 0 ? void 0 : _b.value) !== null && _c !== void 0 ? _c : newName,
                    } }));
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return tslib.__assign(tslib.__assign({}, node), { selections: newSelections });
    };
    return TransformCompositeFields;
}());

var TransformObjectFields = /** @class */ (function () {
    function TransformObjectFields(objectFieldTransformer, fieldNodeTransformer) {
        this.objectFieldTransformer = objectFieldTransformer;
        this.fieldNodeTransformer = fieldNodeTransformer;
    }
    TransformObjectFields.prototype._getTransformer = function () {
        var transformer = this.transformer;
        if (transformer === undefined) {
            throw new Error("The TransformObjectFields transform's  \"transformRequest\" and \"transformResult\" methods cannot be used without first calling \"transformSchema\".");
        }
        return transformer;
    };
    TransformObjectFields.prototype.transformSchema = function (originalWrappingSchema, subschemaConfig, transformedSchema) {
        var _this = this;
        var compositeToObjectFieldTransformer = function (typeName, fieldName, fieldConfig) {
            if (graphql.isObjectType(originalWrappingSchema.getType(typeName))) {
                return _this.objectFieldTransformer(typeName, fieldName, fieldConfig);
            }
            return undefined;
        };
        this.transformer = new TransformCompositeFields(compositeToObjectFieldTransformer, this.fieldNodeTransformer);
        return this.transformer.transformSchema(originalWrappingSchema, subschemaConfig, transformedSchema);
    };
    TransformObjectFields.prototype.transformRequest = function (originalRequest, delegationContext, transformationContext) {
        return this._getTransformer().transformRequest(originalRequest, delegationContext, transformationContext);
    };
    TransformObjectFields.prototype.transformResult = function (originalResult, delegationContext, transformationContext) {
        return this._getTransformer().transformResult(originalResult, delegationContext, transformationContext);
    };
    return TransformObjectFields;
}());

var TransformRootFields = /** @class */ (function () {
    function TransformRootFields(rootFieldTransformer, fieldNodeTransformer) {
        this.rootFieldTransformer = rootFieldTransformer;
        this.fieldNodeTransformer = fieldNodeTransformer;
    }
    TransformRootFields.prototype._getTransformer = function () {
        var transformer = this.transformer;
        if (transformer === undefined) {
            throw new Error("The TransformRootFields transform's  \"transformRequest\" and \"transformResult\" methods cannot be used without first calling \"transformSchema\".");
        }
        return transformer;
    };
    TransformRootFields.prototype.transformSchema = function (originalWrappingSchema, subschemaConfig, transformedSchema) {
        var _this = this;
        var rootToObjectFieldTransformer = function (typeName, fieldName, fieldConfig) {
            var _a, _b, _c;
            if (typeName === ((_a = originalWrappingSchema.getQueryType()) === null || _a === void 0 ? void 0 : _a.name)) {
                return _this.rootFieldTransformer('Query', fieldName, fieldConfig);
            }
            if (typeName === ((_b = originalWrappingSchema.getMutationType()) === null || _b === void 0 ? void 0 : _b.name)) {
                return _this.rootFieldTransformer('Mutation', fieldName, fieldConfig);
            }
            if (typeName === ((_c = originalWrappingSchema.getSubscriptionType()) === null || _c === void 0 ? void 0 : _c.name)) {
                return _this.rootFieldTransformer('Subscription', fieldName, fieldConfig);
            }
            return undefined;
        };
        this.transformer = new TransformObjectFields(rootToObjectFieldTransformer, this.fieldNodeTransformer);
        return this.transformer.transformSchema(originalWrappingSchema, subschemaConfig, transformedSchema);
    };
    TransformRootFields.prototype.transformRequest = function (originalRequest, delegationContext, transformationContext) {
        return this._getTransformer().transformRequest(originalRequest, delegationContext, transformationContext);
    };
    TransformRootFields.prototype.transformResult = function (originalResult, delegationContext, transformationContext) {
        return this._getTransformer().transformResult(originalResult, delegationContext, transformationContext);
    };
    return TransformRootFields;
}());

var RenameRootFields = /** @class */ (function () {
    function RenameRootFields(renamer) {
        this.transformer = new TransformRootFields(function (operation, fieldName, fieldConfig) { return [renamer(operation, fieldName, fieldConfig), fieldConfig]; });
    }
    RenameRootFields.prototype.transformSchema = function (originalWrappingSchema, subschemaConfig, transformedSchema) {
        return this.transformer.transformSchema(originalWrappingSchema, subschemaConfig, transformedSchema);
    };
    RenameRootFields.prototype.transformRequest = function (originalRequest, delegationContext, transformationContext) {
        return this.transformer.transformRequest(originalRequest, delegationContext, transformationContext);
    };
    return RenameRootFields;
}());

var FilterRootFields = /** @class */ (function () {
    function FilterRootFields(filter) {
        this.transformer = new TransformRootFields(function (operation, fieldName, fieldConfig) {
            if (filter(operation, fieldName, fieldConfig)) {
                return undefined;
            }
            return null;
        });
    }
    FilterRootFields.prototype.transformSchema = function (originalWrappingSchema, subschemaConfig, transformedSchema) {
        return this.transformer.transformSchema(originalWrappingSchema, subschemaConfig, transformedSchema);
    };
    return FilterRootFields;
}());

var RenameObjectFields = /** @class */ (function () {
    function RenameObjectFields(renamer) {
        this.transformer = new TransformObjectFields(function (typeName, fieldName, fieldConfig) { return [
            renamer(typeName, fieldName, fieldConfig),
            fieldConfig,
        ]; });
    }
    RenameObjectFields.prototype.transformSchema = function (originalWrappingSchema, subschemaConfig, transformedSchema) {
        return this.transformer.transformSchema(originalWrappingSchema, subschemaConfig, transformedSchema);
    };
    RenameObjectFields.prototype.transformRequest = function (originalRequest, delegationContext, transformationContext) {
        return this.transformer.transformRequest(originalRequest, delegationContext, transformationContext);
    };
    return RenameObjectFields;
}());

var FilterObjectFields = /** @class */ (function () {
    function FilterObjectFields(filter) {
        this.transformer = new TransformObjectFields(function (typeName, fieldName, fieldConfig) {
            return filter(typeName, fieldName, fieldConfig) ? undefined : null;
        });
    }
    FilterObjectFields.prototype.transformSchema = function (originalWrappingSchema, subschemaConfig, transformedSchema) {
        return this.transformer.transformSchema(originalWrappingSchema, subschemaConfig, transformedSchema);
    };
    return FilterObjectFields;
}());

var TransformInterfaceFields = /** @class */ (function () {
    function TransformInterfaceFields(interfaceFieldTransformer, fieldNodeTransformer) {
        this.interfaceFieldTransformer = interfaceFieldTransformer;
        this.fieldNodeTransformer = fieldNodeTransformer;
    }
    TransformInterfaceFields.prototype._getTransformer = function () {
        var transformer = this.transformer;
        if (transformer === undefined) {
            throw new Error("The TransformInterfaceFields transform's  \"transformRequest\" and \"transformResult\" methods cannot be used without first calling \"transformSchema\".");
        }
        return transformer;
    };
    TransformInterfaceFields.prototype.transformSchema = function (originalWrappingSchema, subschemaConfig, transformedSchema) {
        var _this = this;
        var compositeToObjectFieldTransformer = function (typeName, fieldName, fieldConfig) {
            if (graphql.isInterfaceType(originalWrappingSchema.getType(typeName))) {
                return _this.interfaceFieldTransformer(typeName, fieldName, fieldConfig);
            }
            return undefined;
        };
        this.transformer = new TransformCompositeFields(compositeToObjectFieldTransformer, this.fieldNodeTransformer);
        return this.transformer.transformSchema(originalWrappingSchema, subschemaConfig, transformedSchema);
    };
    TransformInterfaceFields.prototype.transformRequest = function (originalRequest, delegationContext, transformationContext) {
        return this._getTransformer().transformRequest(originalRequest, delegationContext, transformationContext);
    };
    TransformInterfaceFields.prototype.transformResult = function (originalResult, delegationContext, transformationContext) {
        return this._getTransformer().transformResult(originalResult, delegationContext, transformationContext);
    };
    return TransformInterfaceFields;
}());

var RenameInterfaceFields = /** @class */ (function () {
    function RenameInterfaceFields(renamer) {
        this.transformer = new TransformInterfaceFields(function (typeName, fieldName, fieldConfig) { return [
            renamer(typeName, fieldName, fieldConfig),
            fieldConfig,
        ]; });
    }
    RenameInterfaceFields.prototype.transformSchema = function (originalWrappingSchema, subschemaConfig, transformedSchema) {
        return this.transformer.transformSchema(originalWrappingSchema, subschemaConfig, transformedSchema);
    };
    RenameInterfaceFields.prototype.transformRequest = function (originalRequest, delegationContext, transformationContext) {
        return this.transformer.transformRequest(originalRequest, delegationContext, transformationContext);
    };
    return RenameInterfaceFields;
}());

var FilterInterfaceFields = /** @class */ (function () {
    function FilterInterfaceFields(filter) {
        this.transformer = new TransformInterfaceFields(function (typeName, fieldName, fieldConfig) {
            return filter(typeName, fieldName, fieldConfig) ? undefined : null;
        });
    }
    FilterInterfaceFields.prototype.transformSchema = function (originalWrappingSchema, subschemaConfig, transformedSchema) {
        return this.transformer.transformSchema(originalWrappingSchema, subschemaConfig, transformedSchema);
    };
    return FilterInterfaceFields;
}());

var TransformInputObjectFields = /** @class */ (function () {
    function TransformInputObjectFields(inputFieldTransformer, inputFieldNodeTransformer, inputObjectNodeTransformer) {
        this.inputFieldTransformer = inputFieldTransformer;
        this.inputFieldNodeTransformer = inputFieldNodeTransformer;
        this.inputObjectNodeTransformer = inputObjectNodeTransformer;
        this.mapping = {};
    }
    TransformInputObjectFields.prototype._getTransformedSchema = function () {
        var transformedSchema = this.transformedSchema;
        if (transformedSchema === undefined) {
            throw new Error("The TransformInputObjectFields transform's  \"transformRequest\" and \"transformResult\" methods cannot be used without first calling \"transformSchema\".");
        }
        return transformedSchema;
    };
    TransformInputObjectFields.prototype.transformSchema = function (originalWrappingSchema, _subschemaConfig, _transformedSchema) {
        var _a;
        var _this = this;
        this.transformedSchema = utils.mapSchema(originalWrappingSchema, (_a = {},
            _a[utils.MapperKind.INPUT_OBJECT_FIELD] = function (inputFieldConfig, fieldName, typeName) {
                var transformedInputField = _this.inputFieldTransformer(typeName, fieldName, inputFieldConfig);
                if (Array.isArray(transformedInputField)) {
                    var newFieldName = transformedInputField[0];
                    if (newFieldName !== fieldName) {
                        if (!(typeName in _this.mapping)) {
                            _this.mapping[typeName] = {};
                        }
                        _this.mapping[typeName][newFieldName] = fieldName;
                    }
                }
                return transformedInputField;
            },
            _a));
        return this.transformedSchema;
    };
    TransformInputObjectFields.prototype.transformRequest = function (originalRequest, delegationContext, _transformationContext) {
        var e_1, _a, e_2, _b, e_3, _c, e_4, _d;
        var _this = this;
        var _e;
        var variableValues = (_e = originalRequest.variables) !== null && _e !== void 0 ? _e : {};
        var fragments = Object.create(null);
        var operations = [];
        try {
            for (var _f = tslib.__values(originalRequest.document.definitions), _g = _f.next(); !_g.done; _g = _f.next()) {
                var def = _g.value;
                if (def.kind === graphql.Kind.OPERATION_DEFINITION) {
                    operations.push(def);
                }
                else if (def.kind === graphql.Kind.FRAGMENT_DEFINITION) {
                    fragments[def.name.value] = def;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_g && !_g.done && (_a = _f.return)) _a.call(_f);
            }
            finally { if (e_1) throw e_1.error; }
        }
        try {
            for (var operations_1 = tslib.__values(operations), operations_1_1 = operations_1.next(); !operations_1_1.done; operations_1_1 = operations_1.next()) {
                var def = operations_1_1.value;
                var variableDefs = def.variableDefinitions;
                if (variableDefs != null) {
                    try {
                        for (var variableDefs_1 = (e_3 = void 0, tslib.__values(variableDefs)), variableDefs_1_1 = variableDefs_1.next(); !variableDefs_1_1.done; variableDefs_1_1 = variableDefs_1.next()) {
                            var variableDef = variableDefs_1_1.value;
                            var varName = variableDef.variable.name.value;
                            if (variableDef.type.kind !== graphql.Kind.NAMED_TYPE) {
                                throw new Error("Expected " + variableDef.type + " to be a named type");
                            }
                            // requirement for 'as NamedTypeNode' appears to be a bug within types, as function should take any TypeNode
                            var varType = graphql.typeFromAST(delegationContext.transformedSchema, variableDef.type);
                            if (!graphql.isInputType(varType)) {
                                throw new Error("Expected " + varType + " to be an input type");
                            }
                            variableValues[varName] = utils.transformInputValue(varType, variableValues[varName], undefined, function (type, originalValue) {
                                var _a;
                                var newValue = Object.create(null);
                                var fields = type.getFields();
                                for (var key in originalValue) {
                                    var field = fields[key];
                                    if (field != null) {
                                        var newFieldName = (_a = _this.mapping[type.name]) === null || _a === void 0 ? void 0 : _a[field.name];
                                        if (newFieldName != null) {
                                            newValue[newFieldName] = originalValue[field.name];
                                        }
                                        else {
                                            newValue[field.name] = originalValue[field.name];
                                        }
                                    }
                                }
                                return newValue;
                            });
                        }
                    }
                    catch (e_3_1) { e_3 = { error: e_3_1 }; }
                    finally {
                        try {
                            if (variableDefs_1_1 && !variableDefs_1_1.done && (_c = variableDefs_1.return)) _c.call(variableDefs_1);
                        }
                        finally { if (e_3) throw e_3.error; }
                    }
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (operations_1_1 && !operations_1_1.done && (_b = operations_1.return)) _b.call(operations_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
        try {
            for (var _h = tslib.__values(originalRequest.document.definitions.filter(function (def) { return def.kind === graphql.Kind.FRAGMENT_DEFINITION; })), _j = _h.next(); !_j.done; _j = _h.next()) {
                var def = _j.value;
                fragments[def.name.value] = def;
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (_j && !_j.done && (_d = _h.return)) _d.call(_h);
            }
            finally { if (e_4) throw e_4.error; }
        }
        var document = this.transformDocument(originalRequest.document, this.mapping, this.inputFieldNodeTransformer, this.inputObjectNodeTransformer, originalRequest, delegationContext);
        return tslib.__assign(tslib.__assign({}, originalRequest), { document: document, variables: variableValues });
    };
    TransformInputObjectFields.prototype.transformDocument = function (document, mapping, inputFieldNodeTransformer, inputObjectNodeTransformer, request, delegationContext) {
        var _a;
        var typeInfo = new graphql.TypeInfo(this._getTransformedSchema());
        var newDocument = graphql.visit(document, graphql.visitWithTypeInfo(typeInfo, {
            leave: (_a = {},
                _a[graphql.Kind.OBJECT] = function (node) {
                    var e_5, _a, e_6, _b;
                    // The casting is kind of legit here as we are in a visitor
                    var parentType = typeInfo.getInputType();
                    if (parentType != null) {
                        var parentTypeName = parentType.name;
                        var newInputFields = [];
                        try {
                            for (var _c = tslib.__values(node.fields), _d = _c.next(); !_d.done; _d = _c.next()) {
                                var inputField = _d.value;
                                var newName = inputField.name.value;
                                var transformedInputField = inputFieldNodeTransformer != null
                                    ? inputFieldNodeTransformer(parentTypeName, newName, inputField, request, delegationContext)
                                    : inputField;
                                if (Array.isArray(transformedInputField)) {
                                    try {
                                        for (var transformedInputField_1 = (e_6 = void 0, tslib.__values(transformedInputField)), transformedInputField_1_1 = transformedInputField_1.next(); !transformedInputField_1_1.done; transformedInputField_1_1 = transformedInputField_1.next()) {
                                            var individualTransformedInputField = transformedInputField_1_1.value;
                                            var typeMapping_1 = mapping[parentTypeName];
                                            if (typeMapping_1 == null) {
                                                newInputFields.push(individualTransformedInputField);
                                                continue;
                                            }
                                            var oldName_1 = typeMapping_1[newName];
                                            if (oldName_1 == null) {
                                                newInputFields.push(individualTransformedInputField);
                                                continue;
                                            }
                                            newInputFields.push(tslib.__assign(tslib.__assign({}, individualTransformedInputField), { name: tslib.__assign(tslib.__assign({}, individualTransformedInputField.name), { value: oldName_1 }) }));
                                        }
                                    }
                                    catch (e_6_1) { e_6 = { error: e_6_1 }; }
                                    finally {
                                        try {
                                            if (transformedInputField_1_1 && !transformedInputField_1_1.done && (_b = transformedInputField_1.return)) _b.call(transformedInputField_1);
                                        }
                                        finally { if (e_6) throw e_6.error; }
                                    }
                                    continue;
                                }
                                var typeMapping = mapping[parentTypeName];
                                if (typeMapping == null) {
                                    newInputFields.push(transformedInputField);
                                    continue;
                                }
                                var oldName = typeMapping[newName];
                                if (oldName == null) {
                                    newInputFields.push(transformedInputField);
                                    continue;
                                }
                                newInputFields.push(tslib.__assign(tslib.__assign({}, transformedInputField), { name: tslib.__assign(tslib.__assign({}, transformedInputField.name), { value: oldName }) }));
                            }
                        }
                        catch (e_5_1) { e_5 = { error: e_5_1 }; }
                        finally {
                            try {
                                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                            }
                            finally { if (e_5) throw e_5.error; }
                        }
                        var newNode = tslib.__assign(tslib.__assign({}, node), { fields: newInputFields });
                        return inputObjectNodeTransformer != null
                            ? inputObjectNodeTransformer(parentTypeName, newNode, request, delegationContext)
                            : newNode;
                    }
                },
                _a),
        }));
        return newDocument;
    };
    return TransformInputObjectFields;
}());

var RenameInputObjectFields = /** @class */ (function () {
    function RenameInputObjectFields(renamer) {
        var _this = this;
        this.renamer = renamer;
        this.transformer = new TransformInputObjectFields(function (typeName, inputFieldName, inputFieldConfig) {
            var newName = renamer(typeName, inputFieldName, inputFieldConfig);
            if (newName !== undefined && newName !== inputFieldName) {
                var value = renamer(typeName, inputFieldName, inputFieldConfig);
                if (value != null) {
                    return [value, inputFieldConfig];
                }
            }
        }, function (typeName, inputFieldName, inputFieldNode) {
            if (!(typeName in _this.reverseMap)) {
                return inputFieldNode;
            }
            var inputFieldNameMap = _this.reverseMap[typeName];
            if (!(inputFieldName in inputFieldNameMap)) {
                return inputFieldNode;
            }
            return tslib.__assign(tslib.__assign({}, inputFieldNode), { name: tslib.__assign(tslib.__assign({}, inputFieldNode.name), { value: inputFieldNameMap[inputFieldName] }) });
        });
        this.reverseMap = Object.create(null);
    }
    RenameInputObjectFields.prototype.transformSchema = function (originalWrappingSchema, subschemaConfig, transformedSchema) {
        var _a;
        var _this = this;
        utils.mapSchema(originalWrappingSchema, (_a = {},
            _a[utils.MapperKind.INPUT_OBJECT_FIELD] = function (inputFieldConfig, fieldName, typeName) {
                var newName = _this.renamer(typeName, fieldName, inputFieldConfig);
                if (newName !== undefined && newName !== fieldName) {
                    if (_this.reverseMap[typeName] == null) {
                        _this.reverseMap[typeName] = Object.create(null);
                    }
                    _this.reverseMap[typeName][newName] = fieldName;
                }
                return undefined;
            },
            _a[utils.MapperKind.ROOT_OBJECT] = function () {
                return undefined;
            },
            _a));
        return this.transformer.transformSchema(originalWrappingSchema, subschemaConfig, transformedSchema);
    };
    RenameInputObjectFields.prototype.transformRequest = function (originalRequest, delegationContext, transformationContext) {
        return this.transformer.transformRequest(originalRequest, delegationContext, transformationContext);
    };
    return RenameInputObjectFields;
}());

var FilterInputObjectFields = /** @class */ (function () {
    function FilterInputObjectFields(filter, inputObjectNodeTransformer) {
        this.transformer = new TransformInputObjectFields(function (typeName, fieldName, inputFieldConfig) {
            return filter(typeName, fieldName, inputFieldConfig) ? undefined : null;
        }, undefined, inputObjectNodeTransformer);
    }
    FilterInputObjectFields.prototype.transformSchema = function (originalWrappingSchema, subschemaConfig, transformedSchema) {
        return this.transformer.transformSchema(originalWrappingSchema, subschemaConfig, transformedSchema);
    };
    FilterInputObjectFields.prototype.transformRequest = function (originalRequest, delegationContext, transformationContext) {
        return this.transformer.transformRequest(originalRequest, delegationContext, transformationContext);
    };
    return FilterInputObjectFields;
}());

var MapLeafValues = /** @class */ (function () {
    function MapLeafValues(inputValueTransformer, outputValueTransformer) {
        this.inputValueTransformer = inputValueTransformer;
        this.outputValueTransformer = outputValueTransformer;
        this.resultVisitorMap = Object.create(null);
    }
    MapLeafValues.prototype._getTypeInfo = function () {
        var typeInfo = this.typeInfo;
        if (typeInfo === undefined) {
            throw new Error("The MapLeafValues transform's  \"transformRequest\" and \"transformResult\" methods cannot be used without first calling \"transformSchema\".");
        }
        return typeInfo;
    };
    MapLeafValues.prototype._getOriginalWrappingSchema = function () {
        var originalWrappingSchema = this.originalWrappingSchema;
        if (originalWrappingSchema === undefined) {
            throw new Error("The MapLeafValues transform's  \"transformRequest\" and \"transformResult\" methods cannot be used without first calling \"transformSchema\".");
        }
        return originalWrappingSchema;
    };
    MapLeafValues.prototype.transformSchema = function (originalWrappingSchema, _subschemaConfig, _transformedSchema) {
        var _this = this;
        this.originalWrappingSchema = originalWrappingSchema;
        var typeMap = originalWrappingSchema.getTypeMap();
        var _loop_1 = function (typeName) {
            var type = typeMap[typeName];
            if (!typeName.startsWith('__')) {
                if (graphql.isLeafType(type)) {
                    this_1.resultVisitorMap[typeName] = function (value) { return _this.outputValueTransformer(typeName, value); };
                }
            }
        };
        var this_1 = this;
        for (var typeName in typeMap) {
            _loop_1(typeName);
        }
        this.typeInfo = new graphql.TypeInfo(originalWrappingSchema);
        return originalWrappingSchema;
    };
    MapLeafValues.prototype.transformRequest = function (originalRequest, _delegationContext, transformationContext) {
        var document = originalRequest.document;
        var variableValues = (originalRequest.variables = {});
        var operations = document.definitions.filter(function (def) { return def.kind === graphql.Kind.OPERATION_DEFINITION; });
        var fragments = document.definitions.filter(function (def) { return def.kind === graphql.Kind.FRAGMENT_DEFINITION; });
        var newOperations = this.transformOperations(operations, variableValues);
        var transformedRequest = tslib.__assign(tslib.__assign({}, originalRequest), { document: tslib.__assign(tslib.__assign({}, document), { definitions: tslib.__spreadArray(tslib.__spreadArray([], tslib.__read(newOperations)), tslib.__read(fragments)) }), variables: variableValues });
        transformationContext.transformedRequest = transformedRequest;
        return transformedRequest;
    };
    MapLeafValues.prototype.transformResult = function (originalResult, _delegationContext, transformationContext) {
        return utils.visitResult(originalResult, transformationContext.transformedRequest, this._getOriginalWrappingSchema(), this.resultVisitorMap);
    };
    MapLeafValues.prototype.transformOperations = function (operations, variableValues) {
        var _this = this;
        return operations.map(function (operation) {
            var _a;
            var _b;
            var variableDefinitionMap = ((_b = operation.variableDefinitions) !== null && _b !== void 0 ? _b : []).reduce(function (prev, def) {
                var _a;
                return (tslib.__assign(tslib.__assign({}, prev), (_a = {}, _a[def.variable.name.value] = def, _a)));
            }, {});
            var newOperation = graphql.visit(operation, graphql.visitWithTypeInfo(_this._getTypeInfo(), (_a = {},
                _a[graphql.Kind.FIELD] = function (node) { return _this.transformFieldNode(node, variableDefinitionMap, variableValues); },
                _a)));
            return tslib.__assign(tslib.__assign({}, newOperation), { variableDefinitions: Object.values(variableDefinitionMap) });
        });
    };
    MapLeafValues.prototype.transformFieldNode = function (field, variableDefinitionMap, variableValues) {
        var e_1, _a;
        var _this = this;
        var targetField = this._getTypeInfo().getFieldDef();
        var generateVariableName = utils.createVariableNameGenerator(variableDefinitionMap);
        if (!targetField.name.startsWith('__')) {
            var argumentNodes = field.arguments;
            if (argumentNodes != null) {
                var argumentNodeMap = argumentNodes.reduce(function (prev, argument) {
                    var _a;
                    return (tslib.__assign(tslib.__assign({}, prev), (_a = {}, _a[argument.name.value] = argument, _a)));
                }, Object.create(null));
                try {
                    for (var _b = tslib.__values(targetField.args), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var argument = _c.value;
                        var argName = argument.name;
                        var argType = argument.type;
                        var argumentNode = argumentNodeMap[argName];
                        var argValue = argumentNode === null || argumentNode === void 0 ? void 0 : argumentNode.value;
                        var value = void 0;
                        if (argValue != null) {
                            value = graphql.valueFromAST(argValue, argType, variableValues);
                        }
                        utils.updateArgument(argumentNodeMap, variableDefinitionMap, variableValues, argName, generateVariableName(argName), argType, utils.transformInputValue(argType, value, function (t, v) {
                            var newValue = _this.inputValueTransformer(t.name, v);
                            return newValue === undefined ? v : newValue;
                        }));
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                return tslib.__assign(tslib.__assign({}, field), { arguments: Object.values(argumentNodeMap) });
            }
        }
    };
    return MapLeafValues;
}());

var TransformEnumValues = /** @class */ (function () {
    function TransformEnumValues(enumValueTransformer, inputValueTransformer, outputValueTransformer) {
        this.enumValueTransformer = enumValueTransformer;
        this.mapping = Object.create(null);
        this.reverseMapping = Object.create(null);
        this.transformer = new MapLeafValues(generateValueTransformer(inputValueTransformer, this.reverseMapping), generateValueTransformer(outputValueTransformer, this.mapping));
    }
    TransformEnumValues.prototype.transformSchema = function (originalWrappingSchema, subschemaConfig, transformedSchema) {
        var _a;
        var _this = this;
        var mappingSchema = this.transformer.transformSchema(originalWrappingSchema, subschemaConfig, transformedSchema);
        this.transformedSchema = utils.mapSchema(mappingSchema, (_a = {},
            _a[utils.MapperKind.ENUM_VALUE] = function (valueConfig, typeName, _schema, externalValue) {
                return _this.transformEnumValue(typeName, externalValue, valueConfig);
            },
            _a));
        return this.transformedSchema;
    };
    TransformEnumValues.prototype.transformRequest = function (originalRequest, delegationContext, transformationContext) {
        return this.transformer.transformRequest(originalRequest, delegationContext, transformationContext);
    };
    TransformEnumValues.prototype.transformResult = function (originalResult, delegationContext, transformationContext) {
        return this.transformer.transformResult(originalResult, delegationContext, transformationContext);
    };
    TransformEnumValues.prototype.transformEnumValue = function (typeName, externalValue, enumValueConfig) {
        var transformedEnumValue = this.enumValueTransformer(typeName, externalValue, enumValueConfig);
        if (Array.isArray(transformedEnumValue)) {
            var newExternalValue = transformedEnumValue[0];
            if (newExternalValue !== externalValue) {
                if (!(typeName in this.mapping)) {
                    this.mapping[typeName] = Object.create(null);
                    this.reverseMapping[typeName] = Object.create(null);
                }
                this.mapping[typeName][externalValue] = newExternalValue;
                this.reverseMapping[typeName][newExternalValue] = externalValue;
            }
        }
        return transformedEnumValue;
    };
    return TransformEnumValues;
}());
function mapEnumValues(typeName, value, mapping) {
    var _a;
    var newExternalValue = (_a = mapping[typeName]) === null || _a === void 0 ? void 0 : _a[value];
    return newExternalValue != null ? newExternalValue : value;
}
function generateValueTransformer(valueTransformer, mapping) {
    if (valueTransformer == null) {
        return function (typeName, value) { return mapEnumValues(typeName, value, mapping); };
    }
    else {
        return function (typeName, value) { return mapEnumValues(typeName, valueTransformer(typeName, value), mapping); };
    }
}

var TransformQuery = /** @class */ (function () {
    function TransformQuery(_a) {
        var path = _a.path, queryTransformer = _a.queryTransformer, _b = _a.resultTransformer, resultTransformer = _b === void 0 ? function (result) { return result; } : _b, _c = _a.errorPathTransformer, errorPathTransformer = _c === void 0 ? function (errorPath) { return tslib.__spreadArray([], tslib.__read(errorPath)); } : _c, _d = _a.fragments, fragments = _d === void 0 ? {} : _d;
        this.path = path;
        this.queryTransformer = queryTransformer;
        this.resultTransformer = resultTransformer;
        this.errorPathTransformer = errorPathTransformer;
        this.fragments = fragments;
    }
    TransformQuery.prototype.transformRequest = function (originalRequest, delegationContext, transformationContext) {
        var _a;
        var _this = this;
        var pathLength = this.path.length;
        var index = 0;
        var document = graphql.visit(originalRequest.document, (_a = {},
            _a[graphql.Kind.FIELD] = {
                enter: function (node) {
                    if (index === pathLength || node.name.value !== _this.path[index] || node.selectionSet == null) {
                        return false;
                    }
                    index++;
                    if (index === pathLength) {
                        var selectionSet = _this.queryTransformer(node.selectionSet, _this.fragments, delegationContext, transformationContext);
                        return tslib.__assign(tslib.__assign({}, node), { selectionSet: selectionSet });
                    }
                },
                leave: function () {
                    index--;
                },
            },
            _a));
        return tslib.__assign(tslib.__assign({}, originalRequest), { document: document });
    };
    TransformQuery.prototype.transformResult = function (originalResult, delegationContext, transformationContext) {
        var data = this.transformData(originalResult.data, delegationContext, transformationContext);
        var errors = originalResult.errors;
        return {
            data: data,
            errors: errors != null ? this.transformErrors(errors) : undefined,
        };
    };
    TransformQuery.prototype.transformData = function (data, delegationContext, transformationContext) {
        var leafIndex = this.path.length - 1;
        var index = 0;
        var newData = data;
        if (newData) {
            var next = this.path[index];
            while (index < leafIndex) {
                if (data[next]) {
                    newData = newData[next];
                }
                else {
                    break;
                }
                index++;
                next = this.path[index];
            }
            newData[next] = this.resultTransformer(newData[next], delegationContext, transformationContext);
        }
        return newData;
    };
    TransformQuery.prototype.transformErrors = function (errors) {
        var _this = this;
        return errors.map(function (error) {
            var path = error.path;
            if (path == null) {
                return error;
            }
            var match = true;
            var index = 0;
            while (index < _this.path.length) {
                if (path[index] !== _this.path[index]) {
                    match = false;
                    break;
                }
                index++;
            }
            var newPath = match ? path.slice(0, index).concat(_this.errorPathTransformer(path.slice(index))) : path;
            return utils.relocatedError(error, newPath);
        });
    };
    return TransformQuery;
}());

var FilterObjectFieldDirectives = /** @class */ (function () {
    function FilterObjectFieldDirectives(filter) {
        this.filter = filter;
    }
    FilterObjectFieldDirectives.prototype.transformSchema = function (originalWrappingSchema, subschemaConfig, transformedSchema) {
        var _this = this;
        var transformer = new TransformObjectFields(function (_typeName, _fieldName, fieldConfig) {
            var _a, _b, _c, _d;
            var keepDirectives = (_c = (_b = (_a = fieldConfig.astNode) === null || _a === void 0 ? void 0 : _a.directives) === null || _b === void 0 ? void 0 : _b.filter(function (dir) {
                var directiveDef = originalWrappingSchema.getDirective(dir.name.value);
                var directiveValue = directiveDef ? utils.getArgumentValues(directiveDef, dir) : undefined;
                return _this.filter(dir.name.value, directiveValue);
            })) !== null && _c !== void 0 ? _c : [];
            if (((_d = fieldConfig.astNode) === null || _d === void 0 ? void 0 : _d.directives) != null &&
                keepDirectives.length !== fieldConfig.astNode.directives.length) {
                fieldConfig = tslib.__assign(tslib.__assign({}, fieldConfig), { astNode: tslib.__assign(tslib.__assign({}, fieldConfig.astNode), { directives: keepDirectives }) });
                return fieldConfig;
            }
        });
        return transformer.transformSchema(originalWrappingSchema, subschemaConfig, transformedSchema);
    };
    return FilterObjectFieldDirectives;
}());

var RemoveObjectFieldDirectives = /** @class */ (function () {
    function RemoveObjectFieldDirectives(directiveName, args) {
        if (args === void 0) { args = {}; }
        this.transformer = new FilterObjectFieldDirectives(function (dirName, dirValue) {
            return !(utils.valueMatchesCriteria(dirName, directiveName) && utils.valueMatchesCriteria(dirValue, args));
        });
    }
    RemoveObjectFieldDirectives.prototype.transformSchema = function (originalWrappingSchema, subschemaConfig, transformedSchema) {
        return this.transformer.transformSchema(originalWrappingSchema, subschemaConfig, transformedSchema);
    };
    return RemoveObjectFieldDirectives;
}());

var RemoveObjectFieldsWithDirective = /** @class */ (function () {
    function RemoveObjectFieldsWithDirective(directiveName, args) {
        if (args === void 0) { args = {}; }
        this.directiveName = directiveName;
        this.args = args;
    }
    RemoveObjectFieldsWithDirective.prototype.transformSchema = function (originalWrappingSchema, subschemaConfig, transformedSchema) {
        var _this = this;
        var transformer = new FilterObjectFields(function (_typeName, _fieldName, fieldConfig) {
            var directives = utils.getDirectives(originalWrappingSchema, fieldConfig);
            return !directives.some(function (directive) {
                return utils.valueMatchesCriteria(directive.name, _this.directiveName) && utils.valueMatchesCriteria(directive.args, _this.args);
            });
        });
        return transformer.transformSchema(originalWrappingSchema, subschemaConfig, transformedSchema);
    };
    return RemoveObjectFieldsWithDirective;
}());

var RemoveObjectFieldDeprecations = /** @class */ (function () {
    function RemoveObjectFieldDeprecations(reason) {
        var args = { reason: reason };
        this.removeDirectives = new FilterObjectFieldDirectives(function (dirName, dirValue) {
            return !(dirName === 'deprecated' && utils.valueMatchesCriteria(dirValue, args));
        });
        this.removeDeprecations = new TransformObjectFields(function (_typeName, _fieldName, fieldConfig) {
            if (fieldConfig.deprecationReason && utils.valueMatchesCriteria(fieldConfig.deprecationReason, reason)) {
                fieldConfig = tslib.__assign({}, fieldConfig);
                delete fieldConfig.deprecationReason;
            }
            return fieldConfig;
        });
    }
    RemoveObjectFieldDeprecations.prototype.transformSchema = function (originalWrappingSchema, subschemaConfig, transformedSchema) {
        return this.removeDeprecations.transformSchema(this.removeDirectives.transformSchema(originalWrappingSchema, subschemaConfig, transformedSchema), subschemaConfig, transformedSchema);
    };
    return RemoveObjectFieldDeprecations;
}());

var RemoveObjectFieldsWithDeprecation = /** @class */ (function () {
    function RemoveObjectFieldsWithDeprecation(reason) {
        this.transformer = new FilterObjectFields(function (_typeName, _fieldName, fieldConfig) {
            if (fieldConfig.deprecationReason) {
                return !utils.valueMatchesCriteria(fieldConfig.deprecationReason, reason);
            }
            return true;
        });
    }
    RemoveObjectFieldsWithDeprecation.prototype.transformSchema = function (originalWrappingSchema, subschemaConfig, transformedSchema) {
        return this.transformer.transformSchema(originalWrappingSchema, subschemaConfig, transformedSchema);
    };
    return RemoveObjectFieldsWithDeprecation;
}());

var PruneTypes = /** @class */ (function () {
    function PruneTypes(options) {
        if (options === void 0) { options = {}; }
        this.options = options;
    }
    PruneTypes.prototype.transformSchema = function (originalWrappingSchema, _subschemaConfig, _transformedSchema) {
        return utils.pruneSchema(originalWrappingSchema, this.options);
    };
    return PruneTypes;
}());

var MapFields = /** @class */ (function () {
    function MapFields(fieldNodeTransformerMap, objectValueTransformerMap, errorsTransformer) {
        this.fieldNodeTransformerMap = fieldNodeTransformerMap;
        this.objectValueTransformerMap = objectValueTransformerMap;
        this.errorsTransformer = errorsTransformer;
    }
    MapFields.prototype._getTransformer = function () {
        var transformer = this.transformer;
        if (transformer === undefined) {
            throw new Error("The MapFields transform's  \"transformRequest\" and \"transformResult\" methods cannot be used without first calling \"transformSchema\".");
        }
        return transformer;
    };
    MapFields.prototype.transformSchema = function (originalWrappingSchema, subschemaConfig, transformedSchema) {
        var _this = this;
        var _a;
        var subscriptionTypeName = (_a = originalWrappingSchema.getSubscriptionType()) === null || _a === void 0 ? void 0 : _a.name;
        var objectValueTransformerMap = this.objectValueTransformerMap;
        this.transformer = new TransformCompositeFields(function () { return undefined; }, function (typeName, fieldName, fieldNode, fragments, transformationContext) {
            var typeTransformers = _this.fieldNodeTransformerMap[typeName];
            if (typeTransformers == null) {
                return undefined;
            }
            var fieldNodeTransformer = typeTransformers[fieldName];
            if (fieldNodeTransformer == null) {
                return undefined;
            }
            return fieldNodeTransformer(fieldNode, fragments, transformationContext);
        }, objectValueTransformerMap != null
            ? function (data, transformationContext) {
                if (data == null) {
                    return data;
                }
                var typeName = data.__typename;
                if (typeName == null) {
                    // see https://github.com/ardatan/graphql-tools/issues/2282
                    typeName = subscriptionTypeName;
                    if (typeName == null) {
                        return data;
                    }
                }
                var transformer = objectValueTransformerMap[typeName];
                if (transformer == null) {
                    return data;
                }
                return transformer(data, transformationContext);
            }
            : undefined, this.errorsTransformer != null ? this.errorsTransformer : undefined);
        return this.transformer.transformSchema(originalWrappingSchema, subschemaConfig, transformedSchema);
    };
    MapFields.prototype.transformRequest = function (originalRequest, delegationContext, transformationContext) {
        return this._getTransformer().transformRequest(originalRequest, delegationContext, transformationContext);
    };
    MapFields.prototype.transformResult = function (originalResult, delegationContext, transformationContext) {
        return this._getTransformer().transformResult(originalResult, delegationContext, transformationContext);
    };
    return MapFields;
}());

var WrapFields = /** @class */ (function () {
    function WrapFields(outerTypeName, wrappingFieldNames, wrappingTypeNames, fieldNames, prefix) {
        var _a, _b, _c;
        if (prefix === void 0) { prefix = 'gqtld'; }
        this.outerTypeName = outerTypeName;
        this.wrappingFieldNames = wrappingFieldNames;
        this.wrappingTypeNames = wrappingTypeNames;
        this.numWraps = wrappingFieldNames.length;
        this.fieldNames = fieldNames;
        var remainingWrappingFieldNames = this.wrappingFieldNames.slice();
        var outerMostWrappingFieldName = remainingWrappingFieldNames.shift();
        if (outerMostWrappingFieldName == null) {
            throw new Error("Cannot wrap fields, no wrapping field name provided.");
        }
        this.transformer = new MapFields((_a = {},
            _a[outerTypeName] = (_b = {},
                _b[outerMostWrappingFieldName] = function (fieldNode, fragments, transformationContext) {
                    return hoistFieldNodes({
                        fieldNode: fieldNode,
                        path: remainingWrappingFieldNames,
                        fieldNames: fieldNames,
                        fragments: fragments,
                        transformationContext: transformationContext,
                        prefix: prefix,
                    });
                },
                _b),
            _a), (_c = {},
            _c[outerTypeName] = function (value, context) { return dehoistValue(value, context); },
            _c), function (errors, context) { return dehoistErrors(errors, context); });
    }
    WrapFields.prototype.transformSchema = function (originalWrappingSchema, subschemaConfig, transformedSchema) {
        var _a, _b, _c;
        var _d, _e, _f, _g;
        var fieldNames = this.fieldNames;
        var targetFieldConfigMap = utils.selectObjectFields(originalWrappingSchema, this.outerTypeName, !fieldNames ? function () { return true; } : function (fieldName) { return fieldNames.includes(fieldName); });
        var newTargetFieldConfigMap = Object.create(null);
        for (var fieldName in targetFieldConfigMap) {
            var field = targetFieldConfigMap[fieldName];
            var newField = tslib.__assign(tslib.__assign({}, field), { resolve: delegate.defaultMergedResolver });
            newTargetFieldConfigMap[fieldName] = newField;
        }
        var wrapIndex = this.numWraps - 1;
        var wrappingTypeName = this.wrappingTypeNames[wrapIndex];
        var wrappingFieldName = this.wrappingFieldNames[wrapIndex];
        var newSchema = utils.appendObjectFields(originalWrappingSchema, wrappingTypeName, newTargetFieldConfigMap);
        for (wrapIndex--; wrapIndex > -1; wrapIndex--) {
            var nextWrappingTypeName = this.wrappingTypeNames[wrapIndex];
            newSchema = utils.appendObjectFields(newSchema, nextWrappingTypeName, (_a = {},
                _a[wrappingFieldName] = {
                    type: newSchema.getType(wrappingTypeName),
                    resolve: delegate.defaultMergedResolver,
                },
                _a));
            wrappingTypeName = nextWrappingTypeName;
            wrappingFieldName = this.wrappingFieldNames[wrapIndex];
        }
        var wrappingRootField = this.outerTypeName === ((_d = originalWrappingSchema.getQueryType()) === null || _d === void 0 ? void 0 : _d.name) ||
            this.outerTypeName === ((_e = originalWrappingSchema.getMutationType()) === null || _e === void 0 ? void 0 : _e.name);
        var resolve;
        if (transformedSchema) {
            if (wrappingRootField) {
                var targetSchema = subschemaConfig.schema;
                var operation = this.outerTypeName === ((_f = targetSchema.getQueryType()) === null || _f === void 0 ? void 0 : _f.name) ? 'query' : 'mutation';
                var createProxyingResolver = (_g = subschemaConfig.createProxyingResolver) !== null && _g !== void 0 ? _g : defaultCreateProxyingResolver;
                resolve = createProxyingResolver({
                    subschemaConfig: subschemaConfig,
                    transformedSchema: transformedSchema,
                    operation: operation,
                    fieldName: wrappingFieldName,
                });
            }
            else {
                resolve = delegate.defaultMergedResolver;
            }
        }
        _c = tslib.__read(utils.modifyObjectFields(newSchema, this.outerTypeName, function (fieldName) { return !!newTargetFieldConfigMap[fieldName]; }, (_b = {},
            _b[wrappingFieldName] = {
                type: newSchema.getType(wrappingTypeName),
                resolve: resolve,
            },
            _b)), 1), newSchema = _c[0];
        return this.transformer.transformSchema(newSchema, subschemaConfig, transformedSchema);
    };
    WrapFields.prototype.transformRequest = function (originalRequest, delegationContext, transformationContext) {
        transformationContext.nextIndex = 0;
        transformationContext.paths = Object.create(null);
        return this.transformer.transformRequest(originalRequest, delegationContext, transformationContext);
    };
    WrapFields.prototype.transformResult = function (originalResult, delegationContext, transformationContext) {
        return this.transformer.transformResult(originalResult, delegationContext, transformationContext);
    };
    return WrapFields;
}());
function collectFields(selectionSet, fragments, fields, visitedFragmentNames) {
    var e_1, _a;
    if (fields === void 0) { fields = []; }
    if (visitedFragmentNames === void 0) { visitedFragmentNames = {}; }
    if (selectionSet != null) {
        try {
            for (var _b = tslib.__values(selectionSet.selections), _c = _b.next(); !_c.done; _c = _b.next()) {
                var selection = _c.value;
                switch (selection.kind) {
                    case graphql.Kind.FIELD:
                        fields.push(selection);
                        break;
                    case graphql.Kind.INLINE_FRAGMENT:
                        collectFields(selection.selectionSet, fragments, fields, visitedFragmentNames);
                        break;
                    case graphql.Kind.FRAGMENT_SPREAD: {
                        var fragmentName = selection.name.value;
                        if (!visitedFragmentNames[fragmentName]) {
                            visitedFragmentNames[fragmentName] = true;
                            collectFields(fragments[fragmentName].selectionSet, fragments, fields, visitedFragmentNames);
                        }
                        break;
                    }
                    default:
                        // unreachable
                        break;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    return fields;
}
function aliasFieldNode(fieldNode, str) {
    return tslib.__assign(tslib.__assign({}, fieldNode), { alias: {
            kind: graphql.Kind.NAME,
            value: str,
        } });
}
function hoistFieldNodes(_a) {
    var e_2, _b, e_3, _c;
    var fieldNode = _a.fieldNode, fieldNames = _a.fieldNames, path = _a.path, fragments = _a.fragments, transformationContext = _a.transformationContext, prefix = _a.prefix, _d = _a.index, index = _d === void 0 ? 0 : _d, _e = _a.wrappingPath, wrappingPath = _e === void 0 ? [] : _e;
    var alias = fieldNode.alias != null ? fieldNode.alias.value : fieldNode.name.value;
    var newFieldNodes = [];
    if (index < path.length) {
        var pathSegment = path[index];
        try {
            for (var _f = tslib.__values(collectFields(fieldNode.selectionSet, fragments)), _g = _f.next(); !_g.done; _g = _f.next()) {
                var possibleFieldNode = _g.value;
                if (possibleFieldNode.name.value === pathSegment) {
                    var newWrappingPath = wrappingPath.concat([alias]);
                    newFieldNodes = newFieldNodes.concat(hoistFieldNodes({
                        fieldNode: possibleFieldNode,
                        fieldNames: fieldNames,
                        path: path,
                        fragments: fragments,
                        transformationContext: transformationContext,
                        prefix: prefix,
                        index: index + 1,
                        wrappingPath: newWrappingPath,
                    }));
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_g && !_g.done && (_b = _f.return)) _b.call(_f);
            }
            finally { if (e_2) throw e_2.error; }
        }
    }
    else {
        try {
            for (var _h = tslib.__values(collectFields(fieldNode.selectionSet, fragments)), _j = _h.next(); !_j.done; _j = _h.next()) {
                var possibleFieldNode = _j.value;
                if (!fieldNames || fieldNames.includes(possibleFieldNode.name.value)) {
                    var nextIndex = transformationContext.nextIndex;
                    transformationContext.nextIndex++;
                    var indexingAlias = "__" + prefix + nextIndex + "__";
                    transformationContext.paths[indexingAlias] = {
                        pathToField: wrappingPath.concat([alias]),
                        alias: possibleFieldNode.alias != null ? possibleFieldNode.alias.value : possibleFieldNode.name.value,
                    };
                    newFieldNodes.push(aliasFieldNode(possibleFieldNode, indexingAlias));
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_j && !_j.done && (_c = _h.return)) _c.call(_h);
            }
            finally { if (e_3) throw e_3.error; }
        }
    }
    return newFieldNodes;
}
function dehoistValue(originalValue, context) {
    var e_4, _a;
    if (originalValue == null) {
        return originalValue;
    }
    var newValue = Object.create(null);
    for (var alias in originalValue) {
        var obj = newValue;
        var path = context.paths[alias];
        if (path == null) {
            newValue[alias] = originalValue[alias];
            continue;
        }
        var pathToField = path.pathToField;
        var fieldAlias = path.alias;
        try {
            for (var pathToField_1 = (e_4 = void 0, tslib.__values(pathToField)), pathToField_1_1 = pathToField_1.next(); !pathToField_1_1.done; pathToField_1_1 = pathToField_1.next()) {
                var key = pathToField_1_1.value;
                obj = obj[key] = obj[key] || Object.create(null);
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (pathToField_1_1 && !pathToField_1_1.done && (_a = pathToField_1.return)) _a.call(pathToField_1);
            }
            finally { if (e_4) throw e_4.error; }
        }
        obj[fieldAlias] = originalValue[alias];
    }
    return newValue;
}
function dehoistErrors(errors, context) {
    if (errors === undefined) {
        return undefined;
    }
    return errors.map(function (error) {
        var e_5, _a;
        var originalPath = error.path;
        if (originalPath == null) {
            return error;
        }
        var newPath = [];
        try {
            for (var originalPath_1 = tslib.__values(originalPath), originalPath_1_1 = originalPath_1.next(); !originalPath_1_1.done; originalPath_1_1 = originalPath_1.next()) {
                var pathSegment = originalPath_1_1.value;
                if (typeof pathSegment !== 'string') {
                    newPath.push(pathSegment);
                    continue;
                }
                var path = context.paths[pathSegment];
                if (path == null) {
                    newPath.push(pathSegment);
                    continue;
                }
                newPath = newPath.concat(path.pathToField, [path.alias]);
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (originalPath_1_1 && !originalPath_1_1.done && (_a = originalPath_1.return)) _a.call(originalPath_1);
            }
            finally { if (e_5) throw e_5.error; }
        }
        return utils.relocatedError(error, newPath);
    });
}

var WrapType = /** @class */ (function () {
    function WrapType(outerTypeName, innerTypeName, fieldName) {
        this.transformer = new WrapFields(outerTypeName, [fieldName], [innerTypeName]);
    }
    WrapType.prototype.transformSchema = function (originalWrappingSchema, subschemaConfig, transformedSchema) {
        return this.transformer.transformSchema(originalWrappingSchema, subschemaConfig, transformedSchema);
    };
    WrapType.prototype.transformRequest = function (originalRequest, delegationContext, transformationContext) {
        return this.transformer.transformRequest(originalRequest, delegationContext, transformationContext);
    };
    WrapType.prototype.transformResult = function (originalResult, delegationContext, transformationContext) {
        return this.transformer.transformResult(originalResult, delegationContext, transformationContext);
    };
    return WrapType;
}());

var HoistField = /** @class */ (function () {
    function HoistField(typeName, pathConfig, newFieldName, alias) {
        var _a, _b, _c;
        if (alias === void 0) { alias = '__gqtlw__'; }
        this.typeName = typeName;
        this.newFieldName = newFieldName;
        var path = pathConfig.map(function (segment) { return (typeof segment === 'string' ? segment : segment.fieldName); });
        this.argFilters = pathConfig.map(function (segment, index) {
            if (typeof segment === 'string' || segment.argFilter == null) {
                return index === pathConfig.length - 1 ? function () { return true; } : function () { return false; };
            }
            return segment.argFilter;
        });
        var pathToField = path.slice();
        var oldFieldName = pathToField.pop();
        if (oldFieldName == null) {
            throw new Error("Cannot hoist field to " + newFieldName + " on type " + typeName + ", no path provided.");
        }
        this.oldFieldName = oldFieldName;
        this.pathToField = pathToField;
        var argLevels = Object.create(null);
        this.transformer = new MapFields((_a = {},
            _a[typeName] = (_b = {},
                _b[newFieldName] = function (fieldNode) {
                    return wrapFieldNode(renameFieldNode(fieldNode, oldFieldName), pathToField, alias, argLevels);
                },
                _b),
            _a), (_c = {},
            _c[typeName] = function (value) { return unwrapValue(value, alias); },
            _c), function (errors) { return (errors != null ? unwrapErrors(errors, alias) : undefined); });
        this.argLevels = argLevels;
    }
    HoistField.prototype.transformSchema = function (originalWrappingSchema, subschemaConfig, transformedSchema) {
        var _a;
        var _this = this;
        var _b, _c, _d, _e;
        var argsMap = Object.create(null);
        var innerType = this.pathToField.reduce(function (acc, pathSegment, index) {
            var e_1, _a;
            var field = acc.getFields()[pathSegment];
            try {
                for (var _b = tslib.__values(field.args), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var arg = _c.value;
                    if (_this.argFilters[index](arg)) {
                        argsMap[arg.name] = arg;
                        _this.argLevels[arg.name] = index;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return graphql.getNullableType(field.type);
        }, originalWrappingSchema.getType(this.typeName));
        var _f = tslib.__read(utils.removeObjectFields(originalWrappingSchema, innerType.name, function (fieldName) { return fieldName === _this.oldFieldName; }), 2), newSchema = _f[0], targetFieldConfigMap = _f[1];
        var targetField = targetFieldConfigMap[this.oldFieldName];
        var resolve;
        if (transformedSchema) {
            var hoistingToRootField = this.typeName === ((_b = originalWrappingSchema.getQueryType()) === null || _b === void 0 ? void 0 : _b.name) ||
                this.typeName === ((_c = originalWrappingSchema.getMutationType()) === null || _c === void 0 ? void 0 : _c.name);
            if (hoistingToRootField) {
                var targetSchema = subschemaConfig.schema;
                var operation = this.typeName === ((_d = targetSchema.getQueryType()) === null || _d === void 0 ? void 0 : _d.name) ? 'query' : 'mutation';
                var createProxyingResolver = (_e = subschemaConfig.createProxyingResolver) !== null && _e !== void 0 ? _e : defaultCreateProxyingResolver;
                resolve = createProxyingResolver({
                    subschemaConfig: subschemaConfig,
                    transformedSchema: transformedSchema,
                    operation: operation,
                    fieldName: this.newFieldName,
                });
            }
            else {
                resolve = delegate.defaultMergedResolver;
            }
        }
        var newTargetField = tslib.__assign(tslib.__assign({}, targetField), { resolve: resolve });
        var level = this.pathToField.length;
        var args = targetField.args;
        if (args != null) {
            for (var argName in args) {
                var argConfig = args[argName];
                if (argConfig == null) {
                    continue;
                }
                var arg = tslib.__assign(tslib.__assign({}, argConfig), { name: argName, description: argConfig.description, defaultValue: argConfig.defaultValue, extensions: argConfig.extensions, astNode: argConfig.astNode });
                if (this.argFilters[level](arg)) {
                    argsMap[argName] = arg;
                    this.argLevels[arg.name] = level;
                }
            }
        }
        newTargetField.args = argsMap;
        newSchema = utils.appendObjectFields(newSchema, this.typeName, (_a = {},
            _a[this.newFieldName] = newTargetField,
            _a));
        return this.transformer.transformSchema(newSchema, subschemaConfig, transformedSchema);
    };
    HoistField.prototype.transformRequest = function (originalRequest, delegationContext, transformationContext) {
        return this.transformer.transformRequest(originalRequest, delegationContext, transformationContext);
    };
    HoistField.prototype.transformResult = function (originalResult, delegationContext, transformationContext) {
        return this.transformer.transformResult(originalResult, delegationContext, transformationContext);
    };
    return HoistField;
}());
function wrapFieldNode(fieldNode, path, alias, argLevels) {
    return path.reduceRight(function (acc, fieldName, index) { return ({
        kind: graphql.Kind.FIELD,
        alias: {
            kind: graphql.Kind.NAME,
            value: alias,
        },
        name: {
            kind: graphql.Kind.NAME,
            value: fieldName,
        },
        selectionSet: {
            kind: graphql.Kind.SELECTION_SET,
            selections: [acc],
        },
        arguments: fieldNode.arguments != null
            ? fieldNode.arguments.filter(function (arg) { return argLevels[arg.name.value] === index; })
            : undefined,
    }); }, tslib.__assign(tslib.__assign({}, fieldNode), { arguments: fieldNode.arguments != null
            ? fieldNode.arguments.filter(function (arg) { return argLevels[arg.name.value] === path.length; })
            : undefined }));
}
function renameFieldNode(fieldNode, name) {
    return tslib.__assign(tslib.__assign({}, fieldNode), { alias: {
            kind: graphql.Kind.NAME,
            value: fieldNode.alias != null ? fieldNode.alias.value : fieldNode.name.value,
        }, name: {
            kind: graphql.Kind.NAME,
            value: name,
        } });
}
function unwrapValue(originalValue, alias) {
    var newValue = originalValue;
    var object = newValue[alias];
    while (object != null) {
        newValue = object;
        object = newValue[alias];
    }
    delete originalValue[alias];
    Object.assign(originalValue, newValue);
    return originalValue;
}
function unwrapErrors(errors, alias) {
    if (errors === undefined) {
        return undefined;
    }
    return errors.map(function (error) {
        var originalPath = error.path;
        if (originalPath == null) {
            return error;
        }
        var newPath = originalPath.filter(function (pathSegment) { return pathSegment !== alias; });
        return utils.relocatedError(error, newPath);
    });
}

var WrapQuery = /** @class */ (function () {
    function WrapQuery(path, wrapper, extractor) {
        this.path = path;
        this.wrapper = wrapper;
        this.extractor = extractor;
    }
    WrapQuery.prototype.transformRequest = function (originalRequest, _delegationContext, _transformationContext) {
        var _a;
        var _this = this;
        var fieldPath = [];
        var ourPath = JSON.stringify(this.path);
        var document = graphql.visit(originalRequest.document, (_a = {},
            _a[graphql.Kind.FIELD] = {
                enter: function (node) {
                    fieldPath.push(node.name.value);
                    if (node.selectionSet != null && ourPath === JSON.stringify(fieldPath)) {
                        var wrapResult = _this.wrapper(node.selectionSet);
                        // Selection can be either a single selection or a selection set. If it's just one selection,
                        // let's wrap it in a selection set. Otherwise, keep it as is.
                        var selectionSet = wrapResult != null && wrapResult.kind === graphql.Kind.SELECTION_SET
                            ? wrapResult
                            : {
                                kind: graphql.Kind.SELECTION_SET,
                                selections: [wrapResult],
                            };
                        return tslib.__assign(tslib.__assign({}, node), { selectionSet: selectionSet });
                    }
                },
                leave: function () {
                    fieldPath.pop();
                },
            },
            _a));
        return tslib.__assign(tslib.__assign({}, originalRequest), { document: document });
    };
    WrapQuery.prototype.transformResult = function (originalResult, _delegationContext, _transformationContext) {
        var rootData = originalResult.data;
        if (rootData != null) {
            var data = rootData;
            var path = tslib.__spreadArray([], tslib.__read(this.path));
            while (path.length > 1) {
                var next = path.shift();
                if (data[next]) {
                    data = data[next];
                }
            }
            data[path[0]] = this.extractor(data[path[0]]);
        }
        return {
            data: rootData,
            errors: originalResult.errors,
        };
    };
    return WrapQuery;
}());

var ExtractField = /** @class */ (function () {
    function ExtractField(_a) {
        var from = _a.from, to = _a.to;
        this.from = from;
        this.to = to;
    }
    ExtractField.prototype.transformRequest = function (originalRequest, _delegationContext, _transformationContext) {
        var _a, _b;
        var fromSelection;
        var ourPathFrom = JSON.stringify(this.from);
        var ourPathTo = JSON.stringify(this.to);
        var fieldPath = [];
        graphql.visit(originalRequest.document, (_a = {},
            _a[graphql.Kind.FIELD] = {
                enter: function (node) {
                    fieldPath.push(node.name.value);
                    if (ourPathFrom === JSON.stringify(fieldPath)) {
                        fromSelection = node.selectionSet;
                        return graphql.BREAK;
                    }
                },
                leave: function () {
                    fieldPath.pop();
                },
            },
            _a));
        fieldPath = [];
        var document = graphql.visit(originalRequest.document, (_b = {},
            _b[graphql.Kind.FIELD] = {
                enter: function (node) {
                    fieldPath.push(node.name.value);
                    if (ourPathTo === JSON.stringify(fieldPath) && fromSelection != null) {
                        return tslib.__assign(tslib.__assign({}, node), { selectionSet: fromSelection });
                    }
                },
                leave: function () {
                    fieldPath.pop();
                },
            },
            _b));
        return tslib.__assign(tslib.__assign({}, originalRequest), { document: document });
    };
    return ExtractField;
}());

function getSchemaFromIntrospection(introspectionResult, options) {
    var _a, _b;
    if ((_a = introspectionResult === null || introspectionResult === void 0 ? void 0 : introspectionResult.data) === null || _a === void 0 ? void 0 : _a.__schema) {
        return graphql.buildClientSchema(introspectionResult.data, options);
    }
    else if ((_b = introspectionResult === null || introspectionResult === void 0 ? void 0 : introspectionResult.errors) === null || _b === void 0 ? void 0 : _b.length) {
        if (introspectionResult.errors.length > 1) {
            var combinedError = new utils.AggregateError(introspectionResult.errors, 'Could not obtain introspection result');
            throw combinedError;
        }
        var error = introspectionResult.errors[0];
        throw error.originalError || error;
    }
    else {
        throw new Error('Could not obtain introspection result, received: ' + JSON.stringify(introspectionResult));
    }
}
function introspectSchema(executor, context, options) {
    var parsedIntrospectionQuery = graphql.parse(graphql.getIntrospectionQuery(options), options);
    return new valueOrPromise.ValueOrPromise(function () {
        return executor({
            document: parsedIntrospectionQuery,
            operationType: 'query',
            context: context,
        });
    })
        .then(function (introspection) {
        if (utils.isAsyncIterable(introspection)) {
            return introspection.next().then(function (_a) {
                var value = _a.value;
                return value;
            });
        }
        return introspection;
    })
        .then(function (introspection) { return getSchemaFromIntrospection(introspection, options); })
        .resolve();
}

exports.ExtractField = ExtractField;
exports.FilterInputObjectFields = FilterInputObjectFields;
exports.FilterInterfaceFields = FilterInterfaceFields;
exports.FilterObjectFieldDirectives = FilterObjectFieldDirectives;
exports.FilterObjectFields = FilterObjectFields;
exports.FilterRootFields = FilterRootFields;
exports.FilterTypes = FilterTypes;
exports.HoistField = HoistField;
exports.MapFields = MapFields;
exports.MapLeafValues = MapLeafValues;
exports.PruneSchema = PruneTypes;
exports.RemoveObjectFieldDeprecations = RemoveObjectFieldDeprecations;
exports.RemoveObjectFieldDirectives = RemoveObjectFieldDirectives;
exports.RemoveObjectFieldsWithDeprecation = RemoveObjectFieldsWithDeprecation;
exports.RemoveObjectFieldsWithDirective = RemoveObjectFieldsWithDirective;
exports.RenameInputObjectFields = RenameInputObjectFields;
exports.RenameInterfaceFields = RenameInterfaceFields;
exports.RenameObjectFields = RenameObjectFields;
exports.RenameRootFields = RenameRootFields;
exports.RenameRootTypes = RenameRootTypes;
exports.RenameTypes = RenameTypes;
exports.TransformCompositeFields = TransformCompositeFields;
exports.TransformEnumValues = TransformEnumValues;
exports.TransformInputObjectFields = TransformInputObjectFields;
exports.TransformInterfaceFields = TransformInterfaceFields;
exports.TransformObjectFields = TransformObjectFields;
exports.TransformQuery = TransformQuery;
exports.TransformRootFields = TransformRootFields;
exports.WrapFields = WrapFields;
exports.WrapQuery = WrapQuery;
exports.WrapType = WrapType;
exports.defaultCreateProxyingResolver = defaultCreateProxyingResolver;
exports.generateProxyingResolvers = generateProxyingResolvers;
exports.introspectSchema = introspectSchema;
exports.wrapSchema = wrapSchema;
