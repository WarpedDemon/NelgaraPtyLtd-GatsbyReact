import { __awaiter, __generator } from 'tslib';
import { isValidPath, parseGraphQLJSON } from '@graphql-tools/utils/es5';
import { isAbsolute, resolve } from 'path';
import { promises, existsSync, readFileSync } from 'fs';
import { cwd } from 'process';

var readFile = promises.readFile, access = promises.access;
var FILE_EXTENSIONS = ['.json'];
/**
 * This loader loads documents and type definitions from JSON files.
 *
 * The JSON file can be the result of an introspection query made against a schema:
 *
 * ```js
 * const schema = await loadSchema('schema-introspection.json', {
 *   loaders: [
 *     new JsonFileLoader()
 *   ]
 * });
 * ```
 *
 * Or it can be a `DocumentNode` object representing a GraphQL document or type definitions:
 *
 * ```js
 * const documents = await loadDocuments('queries/*.json', {
 *   loaders: [
 *     new GraphQLFileLoader()
 *   ]
 * });
 * ```
 */
var JsonFileLoader = /** @class */ (function () {
    function JsonFileLoader() {
    }
    JsonFileLoader.prototype.canLoad = function (pointer, options) {
        return __awaiter(this, void 0, void 0, function () {
            var normalizedFilePath, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!isValidPath(pointer)) return [3 /*break*/, 4];
                        if (!FILE_EXTENSIONS.find(function (extension) { return pointer.endsWith(extension); })) return [3 /*break*/, 4];
                        normalizedFilePath = isAbsolute(pointer) ? pointer : resolve(options.cwd || cwd(), pointer);
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, access(normalizedFilePath)];
                    case 2:
                        _b.sent();
                        return [2 /*return*/, true];
                    case 3:
                        _a = _b.sent();
                        return [2 /*return*/, false];
                    case 4: return [2 /*return*/, false];
                }
            });
        });
    };
    JsonFileLoader.prototype.canLoadSync = function (pointer, options) {
        if (isValidPath(pointer)) {
            if (FILE_EXTENSIONS.find(function (extension) { return pointer.endsWith(extension); })) {
                var normalizedFilePath = isAbsolute(pointer) ? pointer : resolve(options.cwd || cwd(), pointer);
                return existsSync(normalizedFilePath);
            }
        }
        return false;
    };
    JsonFileLoader.prototype.load = function (pointer, options) {
        return __awaiter(this, void 0, void 0, function () {
            var normalizedFilePath, jsonContent, e_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        normalizedFilePath = isAbsolute(pointer) ? pointer : resolve(options.cwd || cwd(), pointer);
                        return [4 /*yield*/, this.canLoad(normalizedFilePath, options)];
                    case 1:
                        if (!(_a.sent())) {
                            return [2 /*return*/, []];
                        }
                        _a.label = 2;
                    case 2:
                        _a.trys.push([2, 4, , 5]);
                        return [4 /*yield*/, readFile(normalizedFilePath, { encoding: 'utf8' })];
                    case 3:
                        jsonContent = _a.sent();
                        return [2 /*return*/, [parseGraphQLJSON(pointer, jsonContent, options)]];
                    case 4:
                        e_1 = _a.sent();
                        throw new Error("Unable to read JSON file: " + normalizedFilePath + ": " + (e_1.message || /* istanbul ignore next */ e_1));
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    JsonFileLoader.prototype.loadSync = function (pointer, options) {
        var normalizedFilePath = isAbsolute(pointer) ? pointer : resolve(options.cwd || cwd(), pointer);
        if (!this.canLoadSync(normalizedFilePath, options)) {
            return [];
        }
        try {
            var jsonContent = readFileSync(normalizedFilePath, 'utf8');
            return [parseGraphQLJSON(pointer, jsonContent, options)];
        }
        catch (e) {
            throw new Error("Unable to read JSON file: " + normalizedFilePath + ": " + (e.message || /* istanbul ignore next */ e));
        }
    };
    return JsonFileLoader;
}());

export { JsonFileLoader };
